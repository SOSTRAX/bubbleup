<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BubbleUp</title>
    <!-- Tailwind CSS for modern styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Apply the Inter font (or a sans-serif fallback) to the body */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Basic canvas styling */
        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;    /* Canvas will fill its parent width */
            height: 100%;   /* Canvas will fill its parent height */
            cursor: grab;   /* Default cursor for panning */
        }
        /* Cursor changes for different interaction modes */
        canvas.drawing-mode {
            cursor: crosshair; /* Crosshair for drawing new bubbles */
        }
        canvas.drawing-arrow-mode {
            cursor: crosshair; /* Crosshair for drawing new arrows */
        }
        canvas.dragging-mode {
            cursor: grabbing; /* Grabbing hand for dragging existing bubbles or panning */
        }
        canvas.resizing-mode {
            cursor: se-resize; /* For resizing handles */
        }
        canvas.moving-handle {
            cursor: move; /* Specific cursor for moving handles */
        }
        canvas.tail-direction-handle {
            cursor: pointer; /* Pointer for selecting tail direction */
        }
        /* Hide scrollbars but allow content to scroll if needed (controlled by JS pan) */
        .overflow-hidden {
            overflow: hidden;
        }

        /* Modal specific styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen overflow-hidden">

    <div style="position: fixed; top: 5px; left: 10px; font-size: 11px; font-family: sans-serif; color: #555; z-index: 10000; pointer-events: none;">
      © 2025 Michael Dietz · SOSTRAX
    </div>

    <!-- Hidden project/license/contact info -->
    <div style="display: none;">
      <section>
        <h2>About This Project</h2>
        <p><strong>Project:</strong> BubbleUp Image Editor</p>
        <p><strong>Author:</strong> Michael Dietz</p>
        <p>This project is a simple HTML page created to demonstrate the flexibility of the CANVAS.</p>
        <p><strong>License:</strong> MIT License — free to use with attribution. See https://opensource.org/licenses/MIT</p>
        <p>If you’re interested in working together or want to know more, feel free to contact me: mike@sostrax.com</p>
        <p>View this project on GitHub: https://github.com/SOSTRAX/bubbleup</p>
      </section>
    </div>

    <!-- Main Header -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 p-4 text-white shadow-lg z-10">
        <h1 class="text-3xl font-bold text-center">BubbleUp</h1>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow flex flex-col md:flex-row overflow-hidden">
        <!-- Control Panel -->
        <div class="bg-white p-4 shadow-md md:w-64 flex-shrink-0 flex flex-col space-y-2 overflow-y-auto">
            <h2 class="text-xl font-semibold mb-2 text-gray-800">Tools</h2>

            <!-- Image Upload -->
            <div>
                <label for="imageUpload" class="block text-sm font-medium text-gray-700 mb-1">Upload Image</label>
                <!-- Custom File Input -->
                <input type="file" id="imageUpload" accept="image/*" class="hidden">
                <button id="customImageUploadBtn"
                    class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105 w-full"
                >
                    Choose Image
                </button>
                <span id="fileNameDisplay" class="block text-xs text-gray-500 mt-1 truncate">No file chosen</span>
            </div>

            <!-- Create Speech Bubble Button -->
            <button id="createSpeechBubbleBtn"
                class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105"
            >
                Create Speech Bubble
            </button>

            <!-- Create Stretchable Arrow Button -->
            <button id="createArrowBtn"
                class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105"
            >
                Create Stretchable Arrow
            </button>

            <!-- Save Image Button -->
            <button id="saveImageBtn"
                class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105"
            >
                Save Edited Image
            </button>

            <!-- Save Options -->
            <div>
                <input type="checkbox" id="saveImageWithinBounds" checked
                    class="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                >
                <label for="saveImageWithinBounds" class="text-sm font-medium text-gray-700">Save within Original Image Bounds</label>
            </div>

            <!-- How To Button -->
            <button id="howToBtn"
                class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105"
            >
                How To Use
            </button>

            <!-- Double Click To Edit Bubble Label -->
            <p class="text-sm text-gray-600 text-center mt-1">Double Click To Edit Bubble</p>

            <!-- Clear Canvas Button -->
            <button id="clearCanvasBtn"
                class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105"
            >
                Clear Canvas
            </button>

            <!-- Zoom Controls -->
            <div>
                <h3 class="text-lg font-semibold mb-1 text-gray-800">Zoom</h3>
                <div class="flex items-center space-x-2">
                    <button id="zoomOutBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-1 px-3 rounded-lg text-lg">-</button>
                    <span id="zoomLevel" class="text-gray-700">100%</span>
                    <button id="zoomInBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-1 px-3 rounded-lg text-lg">+</button>
                    <button id="resetZoomBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-1 px-3 rounded-lg text-sm">Reset</button>
                </div>
            </div>

            <!-- Debugging Info (Optional) -->
            <div class="mt-4 p-2 bg-gray-50 rounded-md text-sm text-gray-600">
                <h3 class="font-semibold">Debug Info:</h3>
                <p>Mode: <span id="currentMode">idle</span></p>
                <p>Selected Bubble: <span id="selectedBubbleDebug">None</span></p>
                <p>Selected Arrow: <span id="selectedArrowDebug">None</span></p>
            </div>
        </div>

        <!-- Canvas Container -->
        <div id="canvasContainer" class="flex-grow bg-gray-200 relative overflow-hidden flex justify-center items-center">
            <canvas id="imageCanvas" class="bg-white rounded-lg shadow-xl"></canvas>
        </div>
    </main>

    <!-- Speech Bubble Edit Modal -->
    <div id="speechBubbleModal" class="modal-overlay hidden">
        <div class="modal-content w-full md:w-2/3 lg:w-1/2 p-6">
            <h2 id="speechBubbleModalTitle" class="text-2xl font-bold mb-2 text-gray-800">Edit Speech Bubble</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mb-2">
                <div>
                    <label for="speechBubbleTextInput" class="block text-sm font-medium text-gray-700 mb-1">Text:</label>
                    <textarea id="speechBubbleTextInput" rows="2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" placeholder="Enter speech bubble text..." ></textarea>
                </div>
                <div>
                    <label for="bubbleFontSizeInput" class="block text-sm font-medium text-gray-700 mb-1">Font Size:</label>
                    <input type="number" id="bubbleFontSizeInput" value="24" min="8" max="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                </div>
                <div>
                    <label for="bubbleFontFamilySelect" class="block text-sm font-medium text-gray-700 mb-1">Font Family:</label>
                    <select id="bubbleFontFamilySelect" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Tahoma">Tahoma</option>
                        <option value="Trebuchet MS">Trebuchet MS</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Brush Script MT">Brush Script MT</option>
                        <option value="Pacifico">Pacifico</option>
                    </select>
                </div>
                <div>
                    <label for="bubbleRotationInput" class="block text-sm font-medium text-gray-700 mb-1">Rotation (Degrees):</label>
                    <input type="number" id="bubbleRotationInput" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                </div>
                <div>
                    <label for="bubbleFillColorInput" class="block text-sm font-medium text-gray-700 mb-1">Fill Color:</label>
                    <input type="color" id="bubbleFillColorInput" value="#FFFFFF" class="mt-1 block w-full h-10 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" >
                </div>
                <div>
                    <label for="bubbleFillAlphaInput" class="block text-sm font-medium text-gray-700 mb-1">Fill Transparency:</label>
                    <input type="range" id="bubbleFillAlphaInput" min="0" max="1" step="0.05" value="1" class="mt-1 block w-full" >
                </div>
                <div>
                    <label for="bubbleBorderColorInput" class="block text-sm font-medium text-gray-700 mb-1">Border Color:</label>
                    <input type="color" id="bubbleBorderColorInput" value="#000000" class="mt-1 block w-full h-10 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" >
                </div>
                <div>
                    <label for="bubbleBorderAlphaInput" class="block text-sm font-medium text-gray-700 mb-1">Border Transparency:</label>
                    <input type="range" id="bubbleBorderAlphaInput" min="0" max="1" step="0.05" value="1" class="mt-1 block w-full" >
                </div>
                <div>
                    <label for="bubbleBorderWidthInput" class="block text-sm font-medium text-gray-700 mb-1">Border Width:</label>
                    <input type="number" id="bubbleBorderWidthInput" value="2" min="0" max="10" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                </div>
                <div>
                    <label for="bubbleTextColorInput" class="block text-sm font-medium text-gray-700 mb-1">Text Color:</label>
                    <input type="color" id="bubbleTextColorInput" value="#000000" class="mt-1 block w-full h-10 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" >
                </div>
                <div>
                    <label for="bubbleTailSizeInput" class="block text-sm font-medium text-gray-700 mb-1">Tail Base Width:</label>
                    <input type="number" id="bubbleTailSizeInput" value="30" min="0" max="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                </div>
                <div>
                    <label for="bubblePaddingXInput" class="block text-sm font-medium text-gray-700 mb-1">Padding X:</label>
                    <input type="number" id="bubblePaddingXInput" value="20" min="0" max="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                </div>
                <div>
                    <label for="bubblePaddingYInput" class="block text-sm font-medium text-gray-700 mb-1">Padding Y:</label>
                    <input type="number" id="bubblePaddingYInput" value="20" min="0" max="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                </div>
                <div>
                    <label for="bubbleCornerRadiusInput" class="block text-sm font-medium text-gray-700 mb-1">Corner Radius:</label>
                    <input type="number" id="bubbleCornerRadiusInput" value="10" min="0" max="50" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                </div>
                <div class="md:col-span-2 flex items-center justify-start">
                    <input type="checkbox" id="bubbleFlipTextCheckbox"
                        class="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    >
                    <label for="bubbleFlipTextCheckbox" class="text-sm font-medium text-gray-700">Flip Text (180°)</label>
                </div>
            </div>

            <div class="mt-4 flex justify-end space-x-2">
                <button id="deleteSpeechBubbleBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    Delete Bubble
                </button>
                <button id="cancelSpeechBubbleBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    Cancel
                </button>
                <button id="saveSpeechBubbleBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    Save Bubble
                </button>
            </div>
        </div>
    </div>

    <!-- Arrow Edit Modal -->
    <div id="arrowEditModal" class="modal-overlay hidden">
        <div class="modal-content w-full md:w-2/3 lg:w-1/2 p-6">
            <h2 class="text-2xl font-bold mb-2 text-gray-800">Edit Arrow</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mb-2">
                <div>
                    <label for="arrowTextInput" class="block text-sm font-medium text-gray-700 mb-1">Text:</label>
                    <textarea id="arrowTextInput" rows="2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" placeholder="Enter arrow text..."></textarea>
                </div>
                <div>
                    <label for="arrowColorInput" class="block text-sm font-medium text-gray-700 mb-1">Color:</label>
                    <input type="color" id="arrowColorInput" value="#FF0000" class="mt-1 block w-full h-10 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" >
                </div>
                <div>
                    <label for="arrowWidthInput" class="block text-sm font-medium text-gray-700 mb-1">Width:</label>
                    <input type="number" id="arrowWidthInput" value="5" min="1" max="20" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                </div>
                <div>
                    <label for="arrowHeadSizeInput" class="block text-sm font-medium text-gray-700 mb-1">Head Size:</label>
                    <input type="number" id="arrowHeadSizeInput" value="15" min="5" max="50" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                </div>
                <div>
                    <label for="arrowStyleSelect" class="block text-sm font-medium text-gray-700 mb-1">Style:</label>
                    <select id="arrowStyleSelect" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2" >
                        <option value="solid">Solid</option>
                        <option value="dashed">Dashed</option>
                    </select>
                </div>
                <div>
                    <label for="arrowFontSizeInput" class="block text-sm font-medium text-gray-700 mb-1">Font Size:</label>
                    <input type="number" id="arrowFontSizeInput" value="16" min="8" max="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>
                <div>
                    <label for="arrowFontFamilySelect" class="block text-sm font-medium text-gray-700 mb-1">Font Family:</label>
                    <select id="arrowFontFamilySelect" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Tahoma">Tahoma</option>
                        <option value="Trebuchet MS">Trebuchet MS</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Brush Script MT">Brush Script MT</option>
                        <option value="Pacifico">Pacifico</option>
                    </select>
                </div>
                <div>
                    <label for="arrowTextColorInput" class="block text-sm font-medium text-gray-700 mb-1">Text Color:</label>
                    <input type="color" id="arrowTextColorInput" value="#000000" class="mt-1 block w-full h-10 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                </div>
                <div>
                    <label for="arrowTextBgColorInput" class="block text-sm font-medium text-gray-700 mb-1">Text Bg Color:</label>
                    <input type="color" id="arrowTextBgColorInput" value="#FFFFFF" class="mt-1 block w-full h-10 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                </div>
                <div>
                    <label for="arrowTextBgAlphaInput" class="block text-sm font-medium text-gray-700 mb-1">Text Bg Transparency:</label>
                    <input type="range" id="arrowTextBgAlphaInput" min="0" max="1" step="0.05" value="0.8" class="mt-1 block w-full">
                </div>
                <div>
                    <label for="arrowPaddingXInput" class="block text-sm font-medium text-gray-700 mb-1">Text Padding X:</label>
                    <input type="number" id="arrowPaddingXInput" value="10" min="0" max="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>
                <div>
                    <label for="arrowPaddingYInput" class="block text-sm font-medium text-gray-700 mb-1">Text Padding Y:</label>
                    <input type="number" id="arrowPaddingYInput" value="10" min="0" max="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>
                <div class="md:col-span-2 flex items-center justify-start">
                    <input type="checkbox" id="arrowFlipTextCheckbox"
                        class="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    >
                    <label for="arrowFlipTextCheckbox" class="text-sm font-medium text-gray-700">Flip Text Upside Down</label>
                </div>
            </div>
            <div class="mt-4 flex justify-end space-x-2">
                <button id="deleteArrowBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    Delete Arrow
                </button>
                <button id="cancelArrowBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    Cancel
                </button>
                <button id="saveArrowBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    Save Arrow
                </button>
            </div>
        </div>
    </div>


    <!-- General Message Modal -->
    <div id="messageModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 id="messageModalTitle" class="text-xl font-bold mb-4 text-gray-800"></h2>
            <p id="messageModalText" class="text-gray-700 mb-6"></p>
            <div class="flex justify-end">
                <button id="closeMessageModalBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                    OK
                </button>
            </div>
        </div>
    </div>


    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('imageCanvas');
        let ctx = canvas.getContext('2d'); // ✅ Now reassignment is allowed

        // --- UI Elements ---
        const imageUpload = document.getElementById('imageUpload');
        const customImageUploadBtn = document.getElementById('customImageUploadBtn');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const createSpeechBubbleBtn = document.getElementById('createSpeechBubbleBtn');
        const createArrowBtn = document.getElementById('createArrowBtn'); // New arrow button
        const saveImageBtn = document.getElementById('saveImageBtn');
        const saveImageWithinBoundsCheckbox = document.getElementById('saveImageWithinBounds');
        const howToBtn = document.getElementById('howToBtn');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const zoomLevelSpan = document.getElementById('zoomLevel');

        // Speech Bubble Modal Elements
        const speechBubbleModal = document.getElementById('speechBubbleModal');
        const speechBubbleModalTitle = document.getElementById('speechBubbleModalTitle');
        const speechBubbleTextInput = document.getElementById('speechBubbleTextInput');
        const bubbleFontSizeInput = document.getElementById('bubbleFontSizeInput');
        const bubbleFontFamilySelect = document.getElementById('bubbleFontFamilySelect');
        const bubbleRotationInput = document.getElementById('bubbleRotationInput');
        const bubbleFillColorInput = document.getElementById('bubbleFillColorInput');
        const bubbleFillAlphaInput = document.getElementById('bubbleFillAlphaInput'); // New alpha input
        const bubbleBorderColorInput = document.getElementById('bubbleBorderColorInput');
        const bubbleBorderAlphaInput = document.getElementById('bubbleBorderAlphaInput'); // New alpha input
        const bubbleBorderWidthInput = document.getElementById('bubbleBorderWidthInput');
        const bubbleTextColorInput = document.getElementById('bubbleTextColorInput');
        const bubbleTailSizeInput = document.getElementById('bubbleTailSizeInput');
        const bubblePaddingXInput = document.getElementById('bubblePaddingXInput');
        const bubblePaddingYInput = document.getElementById('bubblePaddingYInput');
        const bubbleCornerRadiusInput = document.getElementById('bubbleCornerRadiusInput');
        const bubbleFlipTextCheckbox = document.getElementById('bubbleFlipTextCheckbox'); // New flip checkbox
        const saveSpeechBubbleBtn = document.getElementById('saveSpeechBubbleBtn');
        const cancelSpeechBubbleBtn = document.getElementById('cancelSpeechBubbleBtn');
        const deleteSpeechBubbleBtn = document.getElementById('deleteSpeechBubbleBtn');

        // Arrow Modal Elements
        const arrowEditModal = document.getElementById('arrowEditModal');
        const arrowTextInput = document.getElementById('arrowTextInput'); // New text input
        const arrowColorInput = document.getElementById('arrowColorInput');
        const arrowWidthInput = document.getElementById('arrowWidthInput');
        const arrowHeadSizeInput = document.getElementById('arrowHeadSizeInput');
        const arrowStyleSelect = document.getElementById('arrowStyleSelect');
        const arrowFontSizeInput = document.getElementById('arrowFontSizeInput'); // New font size input
        const arrowFontFamilySelect = document.getElementById('arrowFontFamilySelect'); // New font family input
        const arrowTextColorInput = document.getElementById('arrowTextColorInput'); // New text color input
        const arrowTextBgColorInput = document.getElementById('arrowTextBgColorInput'); // New text background color input
        const arrowTextBgAlphaInput = document.getElementById('arrowTextBgAlphaInput'); // New text background transparency input
        const arrowPaddingXInput = document.getElementById('arrowPaddingXInput'); // New padding X input
        const arrowPaddingYInput = document.getElementById('arrowPaddingYInput'); // New padding Y input
        const arrowFlipTextCheckbox = document.getElementById('arrowFlipTextCheckbox'); // New flip checkbox
        const saveArrowBtn = document.getElementById('saveArrowBtn');
        const cancelArrowBtn = document.getElementById('cancelArrowBtn');
        const deleteArrowBtn = document.getElementById('deleteArrowBtn');


        // General Message Modal Elements
        const messageModal = document.getElementById('messageModal');
        const messageModalTitle = document.getElementById('messageModalTitle');
        const messageModalText = document.getElementById('messageModalText');
        const closeMessageModalBtn = document.getElementById('closeMessageModalBtn');

        // Debugging Info Elements
        const currentModeDebug = document.getElementById('currentMode');
        const selectedBubbleDebug = document.getElementById('selectedBubbleDebug');
        const selectedArrowDebug = document.getElementById('selectedArrowDebug'); // New debug element for arrows


        // --- State Variables ---
        let backgroundImage = new Image();
        let speechBubbles = []; // Stores all drawn speech bubbles
        let arrows = []; // Stores all drawn arrows

        // 'idle', 'drawing', 'dragging', 'panning', 'resizing', 'drawing-arrow', 'moving-handle', 'moving-tail-handle'
        let mode = 'idle';
        let currentDrawingBubble = null; // Holds the bubble being drawn or edited
        let currentDrawingArrow = null; // Holds the arrow being drawn or edited
        let selectedBubbleIndex = -1;   // Index of the currently selected bubble
        let selectedArrowIndex = -1;    // Index of the currently selected arrow
        let selectedHandle = null;      // Which handle of an arrow/bubble tail is being dragged ('start', 'end', or 'tail')

        let isDraggingCanvas = false; // True if the canvas itself is being panned
        let lastMouseX, lastMouseY; // Last mouse position for dragging/panning

        let offsetX = 0; // Canvas pan offset X
        let offsetY = 0; // Canvas pan offset Y
        let scale = 1;   // Canvas zoom scale

        // --- Constants ---
        const RESIZE_HANDLE_SIZE = 10; // Size of the square resize handles for bubbles
        const ARROW_HANDLE_RADIUS = 8; // Radius of the circular handles for arrows
        const TAIL_SELECTION_HANDLE_SIZE = 30; // Larger size for the 8 circular tail selection handles (increased from 20)
        const TAIL_SELECTION_HANDLE_OUTER_OFFSET = 60; // Further offset for tail origin handles to prevent overlap (increased from 40)


        // --- Helper Functions ---

        /**
         * Converts canvas coordinates to actual image coordinates, considering pan and zoom.
         * @param {number} canvasX
         * @param {number} canvasY
         * @returns {{x: number, y: number}}
         */
        function toImageCoords(canvasX, canvasY) {
            return {
                x: (canvasX - offsetX) / scale,
                y: (canvasY - offsetY) / scale
            };
        }

        /**
         * Converts image coordinates to canvas coordinates, considering pan and zoom.
         * @param {number} imageX
         * @param {number} imageY
         * @returns {{x: number, y: number}}
         */
        function toCanvasCoords(imageX, imageY) {
            return {
                x: imageX * scale + offsetX,
                y: imageY * scale + offsetY
            };
        }

        /**
         * Rotates a point (px, py) around a center (cx, cy) by a given angle (in radians).
         * @param {number} px - Point X
         * @param {number} py - Point Y
         * @param {number} cx - Center X
         * @param {number} cy - Center Y
         * @param {number} angle - Angle in radians
         * @returns {{x: number, y: number}} The rotated point.
         */
        function rotatePoint(px, py, cx, cy, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const translatedX = px - cx;
            const translatedY = py - cy;
            const rotatedX = translatedX * cos - translatedY * sin;
            const rotatedY = translatedX * sin + translatedY * cos;
            return { x: rotatedX + cx, y: rotatedY + cy };
        }


        /**
         * Displays a message modal to the user.
         * @param {string} title
         * @param {string} text
         */
        function showMessage(title, text) {
            messageModalTitle.textContent = title;
            messageModalText.innerHTML = text; // Use innerHTML for rich text
            messageModal.classList.remove('hidden');
        }

        /** Hides the message modal. */
        function hideMessage() {
            messageModal.classList.add('hidden');
        }

        /** Shows the speech bubble edit modal. */
        function showSpeechBubbleEditModal() {
            speechBubbleModal.classList.remove('hidden');
        }

        /** Hides the speech bubble edit modal. */
        function hideSpeechBubbleEditModal() {
            speechBubbleModal.classList.add('hidden');
            // Clear inputs when modal is hidden (for good measure, though populated on show)
            speechBubbleTextInput.value = '';
            bubbleFontSizeInput.value = 24;
            bubbleFontFamilySelect.value = 'Arial';
            bubbleRotationInput.value = 0;
            bubbleFillColorInput.value = '#FFFFFF';
            bubbleFillAlphaInput.value = 1;
            bubbleBorderColorInput.value = '#000000';
            bubbleBorderAlphaInput.value = 1;
            bubbleBorderWidthInput.value = 2;
            bubbleTextColorInput.value = '#000000';
            bubbleTailSizeInput.value = 30;
            bubblePaddingXInput.value = 20;
            bubblePaddingYInput.value = 20;
            bubbleCornerRadiusInput.value = 10;
            bubbleFlipTextCheckbox.checked = false;
        }

        /** Shows the arrow edit modal. */
        function showArrowEditModal() {
            arrowEditModal.classList.remove('hidden');
        }

        /** Hides the arrow edit modal. */
        function hideArrowEditModal() {
            arrowEditModal.classList.add('hidden');
            // Clear inputs when modal is hidden (for good measure, though populated on show)
            arrowTextInput.value = '';
            arrowColorInput.value = '#FF0000';
            arrowWidthInput.value = 5;
            arrowHeadSizeInput.value = 15;
            arrowStyleSelect.value = 'solid';
            arrowFontSizeInput.value = 16;
            arrowFontFamilySelect.value = 'Arial';
            arrowTextColorInput.value = '#000000';
            arrowTextBgColorInput.value = '#FFFFFF';
            arrowTextBgAlphaInput.value = 0.8;
            arrowPaddingXInput.value = 10;
            arrowPaddingYInput.value = 10;
            arrowFlipTextCheckbox.checked = false;
        }

        /** Updates the debug information displayed on the UI. */
        function updateDebugInfo() {
            currentModeDebug.textContent = mode;
            selectedBubbleDebug.textContent = selectedBubbleIndex !== -1 ? `Bubble ${selectedBubbleIndex}` : 'None';
            selectedArrowDebug.textContent = selectedArrowIndex !== -1 ? `Arrow ${selectedArrowIndex}` : 'None';
        }

        /** Resizes the canvas to fill its container. */
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }

        /**
         * Clears the canvas and redraws the background image, speech bubbles, and arrows.
         */

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear entire canvas

            // Draw background if exists
            if (backgroundImage.src) {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                ctx.drawImage(backgroundImage, 0, 0, backgroundImage.width, backgroundImage.height);
                ctx.restore();
            }

            // Draw existing speech bubbles
            speechBubbles.forEach((bubble, index) => {
                drawSpeechBubble(bubble, index === selectedBubbleIndex);
            });

            // Draw existing arrows
            arrows.forEach((arrow, index) => {
                drawArrow(arrow, index === selectedArrowIndex);
            });

            // Draw the bubble currently being drawn (if any)
            if (mode === 'drawing' && currentDrawingBubble) {
                drawSpeechBubble(currentDrawingBubble, true, true); // Pass true to hide tail
            }

            // Draw the arrow currently being drawn (if any)
            if (mode === 'drawing-arrow' && currentDrawingArrow) {
                drawArrow(currentDrawingArrow, true); // Highlight as selected
            }
        }

        /**
         * Converts hex color to rgba string.
         * @param {string} hex - Hex color string (e.g., "#RRGGBB").
         * @param {number} alpha - Alpha value (0-1).
         * @returns {string} rgba color string.
         */
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }


        /**
         * Draws a speech bubble on the canvas.
         * @param {object} bubble - The speech bubble object.
         * @param {boolean} isSelected - Whether the bubble is currently selected.
         * @param {boolean} hideTailDuringDraw - Optional. If true, hides the tail during initial drawing of the bubble.
         */



function drawSpeechBubble(bubble, isSelected, hideTailDuringDraw = false) {
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    const x = bubble.x;
    const y = bubble.y;
    const width = bubble.width;
    const height = bubble.height;
    const radius = Math.min(bubble.cornerRadius, width / 2, height / 2);
    const tailSize = bubble.tailSize;
    const tailPosition = bubble.tailPosition;
    const tailTipX = x + bubble.tailTipRelativeX;
    const tailTipY = y + bubble.tailTipRelativeY;

    const HALF_TAIL_BASE = tailSize / 2;
    const bubbleCenterX = x + width / 2;
    const bubbleCenterY = y + height / 2;

    ctx.translate(bubbleCenterX, bubbleCenterY);
    ctx.rotate(bubble.rotation * Math.PI / 180);
    ctx.translate(-bubbleCenterX, -bubbleCenterY);

    ctx.beginPath();
    ctx.moveTo(x + radius, y);

    // Top edge
    if (tailPosition === 'top-left') {
        ctx.lineTo(x + radius + HALF_TAIL_BASE, y);
        ctx.lineTo(tailTipX, tailTipY);
        ctx.lineTo(x + radius - HALF_TAIL_BASE, y);
    }
    else if (tailPosition === 'top-mid') {
        ctx.lineTo(x + width / 2 - HALF_TAIL_BASE, y);
        ctx.lineTo(tailTipX, tailTipY);
        ctx.lineTo(x + width / 2 + HALF_TAIL_BASE, y);
    }
    else if (tailPosition === 'top-right') {
        ctx.lineTo(x + width - radius - HALF_TAIL_BASE, y);
        ctx.lineTo(tailTipX, tailTipY);
        ctx.lineTo(x + width - radius + HALF_TAIL_BASE, y);
    }
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

    // Right edge
    if (tailPosition === 'right-mid') {
        ctx.lineTo(x + width, y + height / 2 - HALF_TAIL_BASE);
        ctx.lineTo(tailTipX, tailTipY);
        ctx.lineTo(x + width, y + height / 2 + HALF_TAIL_BASE);
    }
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

    // Bottom edge
    if (tailPosition === 'bottom-right') {
        ctx.lineTo(x + width - radius + HALF_TAIL_BASE, y + height);
        ctx.lineTo(tailTipX, tailTipY);
        ctx.lineTo(x + width - radius - HALF_TAIL_BASE, y + height);
    }
    else if (tailPosition === 'bottom-mid') {
        ctx.lineTo(x + width / 2 + HALF_TAIL_BASE, y + height);
        ctx.lineTo(tailTipX, tailTipY);
        ctx.lineTo(x + width / 2 - HALF_TAIL_BASE, y + height);
    }
    else if (tailPosition === 'bottom-left') {
        ctx.lineTo(x + radius + HALF_TAIL_BASE, y + height);
        ctx.lineTo(tailTipX, tailTipY);
        ctx.lineTo(x + radius - HALF_TAIL_BASE, y + height);
    }
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

    // Left edge
    if (tailPosition === 'left-mid') {
        ctx.lineTo(x, y + height / 2 + HALF_TAIL_BASE);
        ctx.lineTo(tailTipX, tailTipY);
        ctx.lineTo(x, y + height / 2 - HALF_TAIL_BASE);
    }
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();

    ctx.fillStyle = hexToRgba(bubble.fillColor, bubble.fillAlpha);
    ctx.fill();
    ctx.strokeStyle = hexToRgba(bubble.borderColor, bubble.borderAlpha);
    ctx.lineWidth = bubble.borderWidth;
    ctx.stroke();

    const textX = x + width / 2;
    const textY = y + height / 2;
    ctx.fillStyle = bubble.textColor;
    ctx.font = `${bubble.fontSize}px ${bubble.fontFamily}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.save();
    ctx.translate(textX, textY);
    if (bubble.isTextFlipped) ctx.rotate(Math.PI);
    ctx.translate(-textX, -textY);

    const words = bubble.text.split(' ');
    let line = '', lines = [];
    for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        if (ctx.measureText(testLine).width > width - bubble.paddingX * 2 && i > 0) {
            lines.push(line);
            line = words[i] + ' ';
        } else {
            line = testLine;
        }
    }
    lines.push(line);
    const lineHeight = bubble.fontSize * 1.2;
    let startY = textY - (lines.length * lineHeight) / 2 + lineHeight / 2;

    for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i].trim(), textX, startY + i * lineHeight);
    }
    ctx.restore();

    if (isSelected) {
        ctx.fillStyle = 'red';
        ctx.fillRect(x + width - RESIZE_HANDLE_SIZE / 2, y + height - RESIZE_HANDLE_SIZE / 2, RESIZE_HANDLE_SIZE, RESIZE_HANDLE_SIZE);

        ctx.beginPath();
        ctx.arc(tailTipX, tailTipY, ARROW_HANDLE_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'blue';
        const drawHandle = (relX, relY) => {
            const dx = relX - width / 2;
            const dy = relY - height / 2;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0) {
                relX += (dx / dist) * TAIL_SELECTION_HANDLE_OUTER_OFFSET;
                relY += (dy / dist) * TAIL_SELECTION_HANDLE_OUTER_OFFSET;
            }
            const absX = x + relX;
            const absY = y + relY;
            const rotated = rotatePoint(absX, absY, bubbleCenterX, bubbleCenterY, bubble.rotation * Math.PI / 180);
            ctx.beginPath();
            ctx.arc(rotated.x, rotated.y, TAIL_SELECTION_HANDLE_SIZE / 2 / scale, 0, Math.PI * 2);
            ctx.fill();
        };

        drawHandle(width / 2, 0);
        drawHandle(width / 2, height);
        drawHandle(0, height / 2);
        drawHandle(width, height / 2);
        drawHandle(0, 0);
        drawHandle(width, 0);
        drawHandle(0, height);
        drawHandle(width, height);

        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, width, height);
    }

    ctx.restore();
}










function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
}

function drawArrow(arrow, isSelected) {
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    const { startX, startY, endX, endY, headSize, width: lineWidth, color: lineColor, style: lineStyle,
            text, fontSize, fontFamily, textColor, textBgColor, textBgAlpha,
            paddingX, paddingY, isTextFlipped } = arrow;

    const angle = Math.atan2(endY - startY, endX - startX);

    // --- 1. Draw line ---
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(lineStyle === 'dashed' ? [10, 5] : []);
    ctx.stroke();

    // --- 2. Draw arrow head ---
    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headSize * Math.cos(angle - Math.PI / 6), endY - headSize * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headSize * Math.cos(angle + Math.PI / 6), endY - headSize * Math.sin(angle + Math.PI / 6));
    ctx.stroke();

	// --- 3. Draw arrow text and background ---
	if (text) {
		const midX = (startX + endX) / 2;
		const midY = (startY + endY) / 2;

		ctx.save();
		ctx.translate(midX, midY);

		const angle = Math.atan2(endY - startY, endX - startX);
		ctx.rotate(angle);

		// ✅ Auto flip text if arrow points "backward"
		const shouldAutoFlip = endX < startX;
		const shouldFlip = shouldAutoFlip !== arrow.isTextFlipped;
		if (shouldFlip) ctx.rotate(Math.PI);	
		
		
		//ctx.rotate(angle);
		//if (isTextFlipped) ctx.rotate(Math.PI);

		ctx.font = `${fontSize}px ${fontFamily}`;
		ctx.textAlign = 'center';
		ctx.textBaseline = 'top'; // Changed from 'middle' for manual vertical placement

		const words = text.split(' ');
		const lines = [];
		let line = '';
		let maxLineWidth = 0;
		const maxTextWidth = Math.sqrt((endX - startX)**2 + (endY - startY)**2) * 0.8;

		for (let i = 0; i < words.length; i++) {
			const testLine = line + words[i] + ' ';
			const testWidth = ctx.measureText(testLine).width;
			if (testWidth > maxTextWidth && i > 0) {
				lines.push(line);
				maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line.trim()).width);
				line = words[i] + ' ';
			} else {
				line = testLine;
			}
		}
		lines.push(line);
		maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line.trim()).width);

		const lineHeight = fontSize * 1.1; // slightly tighter
		const totalHeight = lines.length * lineHeight;
		const reducedYPad = paddingY * 0.7; // smaller vertical padding
		const bgWidth = maxLineWidth + 2 * paddingX;
		const bgHeight = totalHeight + 2 * reducedYPad;
		const bgX = -bgWidth / 2;
		const bgY = -bgHeight / 2;

		// ✅ Draw background
		if (textBgAlpha > 0) {
			ctx.fillStyle = hexToRgba(textBgColor, textBgAlpha);
			drawRoundedRect(ctx, bgX, bgY, bgWidth, bgHeight, 5);
		}

		// ✅ Draw text, top-aligned
		ctx.fillStyle = textColor;
		lines.forEach((lineText, i) => {
			ctx.fillText(lineText.trim(), 0, bgY + reducedYPad + i * lineHeight);
		});

		ctx.restore();
	}

    // --- 4. Draw handles if selected ---
    if (isSelected) {
        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(startX, startY, ARROW_HANDLE_RADIUS / scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(endX, endY, ARROW_HANDLE_RADIUS / scale, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}


        /**
         * Checks if the given mouse coordinates are within a speech bubble's bounds.
         * @param {number} mouseX
         * @param {number} mouseY
         * @returns {number} The index of the bubble if hit, otherwise -1.
         */
        function hitTestSpeechBubble(mouseX, mouseY) {
            const imageCoords = toImageCoords(mouseX, mouseY);
            for (let i = speechBubbles.length - 1; i >= 0; i--) {
                const bubble = speechBubbles[i];
                // Rotate mouse coordinates back for accurate hit testing on rotated bubbles
                const cos = Math.cos(-bubble.rotation * Math.PI / 180);
                const sin = Math.sin(-bubble.rotation * Math.PI / 180);

                const centerX = bubble.x + bubble.width / 2;
                const centerY = bubble.y + bubble.height / 2;

                const rotatedX = centerX + (imageCoords.x - centerX) * cos - (imageCoords.y - centerY) * sin;
                const rotatedY = centerY + (imageCoords.x - centerX) * sin + (imageCoords.y - centerY) * cos;

                if (rotatedX >= bubble.x && rotatedX <= bubble.x + bubble.width &&
                    rotatedY >= bubble.y && rotatedY <= bubble.y + bubble.height) {
                    return i;
                }
            }
            return -1;
        }

        /**
         * Checks if the given mouse coordinates are near an arrow's handles.
         * @param {number} mouseX
         * @param {number} mouseY
         * @returns {{index: number, handle: 'start'|'end'|null}}
         */
        function hitTestArrowHandle(mouseX, mouseY) {
            const imageCoords = toImageCoords(mouseX, mouseY);
            for (let i = arrows.length - 1; i >= 0; i--) {
                const arrow = arrows[i];
                const startCanvas = toCanvasCoords(arrow.startX, arrow.startY);
                const endCanvas = toCanvasCoords(arrow.endX, arrow.endY);

                // Check start handle
                const distToStart = Math.sqrt(Math.pow(mouseX - startCanvas.x, 2) + Math.pow(mouseY - startCanvas.y, 2));
                if (distToStart < ARROW_HANDLE_RADIUS) {
                    return { index: i, handle: 'start' };
                }
                // Check end handle
                const distToEnd = Math.sqrt(Math.pow(mouseX - endCanvas.x, 2) + Math.pow(mouseY - endCanvas.y, 2));
                if (distToEnd < ARROW_HANDLE_RADIUS) {
                    return { index: i, handle: 'end' };
                }
            }
            return { index: -1, handle: null };
        }

        /**
         * Checks if the given mouse coordinates are near an arrow line or its text for dragging.
         * @param {number} mouseX
         * @param {number} mouseY
         * @returns {number} The index of the arrow if hit, otherwise -1.
         */
        function hitTestArrowLine(mouseX, mouseY) {
            const imageCoords = toImageCoords(mouseX, mouseY);
            for (let i = arrows.length - 1; i >= 0; i--) {
                const arrow = arrows[i];
                const x1 = arrow.startX;
                const y1 = arrow.startY;
                const x2 = arrow.endX;
                const y2 = arrow.endY;

                // Hit test for the line itself
                const lineLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                if (lineLength > 0) { // Avoid division by zero for zero-length lines
                    // Calculate closest point on segment
                    const dot = (((imageCoords.x - x1) * (x2 - x1)) + ((imageCoords.y - y1) * (y2 - y1))) / Math.pow(lineLength, 2);
                    const closestX = x1 + (dot * (x2 - x1));
                    const closestY = y1 + (dot * (y2 - y1));

                    // Check if the closest point is on the line segment
                    const segmentCheck = (dot >= 0 && dot <= 1);

                    if (segmentCheck) {
                        const distance = Math.sqrt(Math.pow(closestX - imageCoords.x, 2) + Math.pow(closestY - imageCoords.y, 2));
                        // Allow a small tolerance for line selection (e.g., 10 pixels in image coords)
                        if (distance < 15 / scale) { // Increased tolerance
                            return i;
                        }
                    }
                }

                // Hit test for the arrow text (if present)
                if (arrow.text) {
                    ctx.save();
                    ctx.font = `${arrow.fontSize}px ${arrow.fontFamily}`;
                    const words = arrow.text.split(' ');
                    let tempLine = '';
                    let longestLineTextWidth = 0;
                    for (let n = 0; n < words.length; n++) {
                        const testLine = tempLine + words[n] + ' ';
                        const metrics = ctx.measureText(testLine);
                        if (metrics.width > longestLineTextWidth) {
                            longestLineTextWidth = metrics.width;
                        }
                        tempLine = testLine;
                    }
                    ctx.restore();

                    const textWidth = longestLineTextWidth;
                    const textHeight = arrow.fontSize * 1.2 * (arrow.text.split('\n').length); // Approximate total text height, considering actual lines

                    const midX = (arrow.startX + arrow.endX) / 2;
                    const midY = (arrow.startY + arrow.endY) / 2;
                    const angle = Math.atan2(arrow.endY - arrow.startY, arrow.endX - arrow.startX);

                    // Bounding box for the text relative to its rotated center
                    // The text is translated to (midX, midY) and then rotated by 'angle'.
                    // The text itself is then drawn at (0, textDrawY) in that rotated coordinate system.
                    const textDrawY_offset = -textHeight / 2 - arrow.paddingY; // This is the Y offset in the rotated space for the text's center

                    const textRectTopLeftX_local = -textWidth / 2 - arrow.paddingX;
                    const textRectTopLeftY_local = textDrawY_offset - (textHeight / 2) - arrow.paddingY;
                    const textRectBottomRightX_local = textWidth / 2 + arrow.paddingX;
                    const textRectBottomRightY_local = textDrawY_offset + (textHeight / 2) + arrow.paddingY;

                    // Four corners of the rotated bounding box
                    const corners = [
                        {x: textRectTopLeftX_local, y: textRectTopLeftY_local},
                        {x: textRectBottomRightX_local, y: textRectTopLeftY_local},
                        {x: textRectTopLeftX_local, y: textRectBottomRightY_local},
                        {x: textRectBottomRightX_local, y: textRectBottomRightY_local}
                    ];

                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                    // Rotate corners and find min/max for AABB
                    for (const corner of corners) {
                        const rotatedX = corner.x * Math.cos(angle) - corner.y * Math.sin(angle);
                        const rotatedY = corner.x * Math.sin(angle) + corner.y * Math.cos(angle);

                        const globalX = rotatedX + midX;
                        const globalY = rotatedY + midY;

                        minX = Math.min(minX, globalX);
                        minY = Math.min(minY, globalY);
                        maxX = Math.max(maxX, globalX);
                        maxY = Math.max(maxY, globalY);
                    }

                    // Check if mouse is within the axis-aligned bounding box of the rotated text
                    if (imageCoords.x >= minX && imageCoords.x <= maxX &&
                        imageCoords.y >= minY && imageCoords.y <= maxY) {
                        return i;
                    }
                }
            }
            return -1;
        }


        /**
         * Checks if the given mouse coordinates are on the resize handle of the selected speech bubble.
         * @param {number} mouseX
         * @param {number} mouseY
         * @returns {boolean} True if the resize handle is hit, false otherwise.
         */
        function hitTestResizeHandle(mouseX, mouseY) {
            if (selectedBubbleIndex === -1) return false;

            const bubble = speechBubbles[selectedBubbleIndex];
            const handleSize = RESIZE_HANDLE_SIZE * scale; // Adjust handle size by zoom
            const handleX = toCanvasCoords(bubble.x + bubble.width, bubble.y + bubble.height).x - handleSize / 2;
            const handleY = toCanvasCoords(bubble.x + bubble.width, bubble.y + bubble.height).y - handleSize / 2;

            return mouseX >= handleX && mouseX <= handleX + handleSize &&
                   mouseY >= handleY && mouseY <= handleY + handleSize;
        }

        /**
         * Checks if the given mouse coordinates are on the tail handle of the selected speech bubble.
         * @param {number} mouseX
         * @param {number} mouseY
         * @returns {boolean} True if the tail handle is hit, false otherwise.
         */
        function hitTestTailHandle(mouseX, mouseY) {
            if (selectedBubbleIndex === -1 || speechBubbles[selectedBubbleIndex].tailPosition === 'none') return false;
            const bubble = speechBubbles[selectedBubbleIndex];

            // Get the tail tip's absolute image coordinates (unrotated)
            const tailTipImageX_unrotated = bubble.x + bubble.tailTipRelativeX;
            const tailTipImageY_unrotated = bubble.y + bubble.tailTipRelativeY;

            // Apply bubble's rotation to the tail tip's position around the bubble's center
            const bubbleCenterX = bubble.x + bubble.width / 2;
            const bubbleCenterY = bubble.y + bubble.height / 2;

            const rotatedTailTip = rotatePoint(
                tailTipImageX_unrotated,
                tailTipImageY_unrotated,
                bubbleCenterX,
                bubbleCenterY,
                bubble.rotation * Math.PI / 180
            );

            // Convert the rotated tail tip's image coordinates to canvas coordinates
            const tailTipCanvas = toCanvasCoords(rotatedTailTip.x, rotatedTailTip.y);

            const dist = Math.sqrt(Math.pow(mouseX - tailTipCanvas.x, 2) + Math.pow(mouseY - tailTipCanvas.y, 2));
            return dist < ARROW_HANDLE_RADIUS; // Using ARROW_HANDLE_RADIUS for consistency
        }

        /**
         * Checks if the given mouse coordinates are on one of the 8 tail origin selection handles.
         * @param {number} mouseX
         * @param {number} mouseY
         * @returns {{index: number, tailPosition: string, tailTipImageX: number, tailTipImageY: number}|null} Returns object with index, the assigned tail position, and image coordinates of the handle, or null.
         */
        function hitTestTailDirectionHandle(mouseX, mouseY) {
            if (selectedBubbleIndex === -1) return null; // Only hit test if a bubble is selected
            const bubble = speechBubbles[selectedBubbleIndex];
            const selHandleRadius = TAIL_SELECTION_HANDLE_SIZE / 2 / scale; // Radius for the new larger circles

            // Define potential handle centers in image coordinates, relative to bubble's (x,y)
            const handleDefinitions = [
                // Side handles
                { relX: bubble.width / 2, relY: 0, assignedTailPos: 'top-mid' },
                { relX: bubble.width / 2, relY: bubble.height, assignedTailPos: 'bottom-mid' },
                { relX: 0, relY: bubble.height / 2, assignedTailPos: 'left-mid' },
                { relX: bubble.width, relY: bubble.height / 2, assignedTailPos: 'right-mid' },
                // Corner handles
                { relX: 0, relY: 0, assignedTailPos: 'top-left' },
                { relX: bubble.width, relY: 0, assignedTailPos: 'top-right' },
                { relX: 0, relY: bubble.height, assignedTailPos: 'bottom-left' },
                { relX: bubble.width, relY: bubble.height, assignedTailPos: 'bottom-right' }
            ];

            const bubbleCenterX = bubble.x + bubble.width / 2;
            const bubbleCenterY = bubble.y + bubble.height / 2;
            const rotationAngle = bubble.rotation * Math.PI / 180;

            for (const def of handleDefinitions) {
                // Calculate handle's absolute image coordinates (unrotated), applying the outer offset
                let handleAbsX_unrotated = bubble.x + def.relX;
                let handleAbsY_unrotated = bubble.y + def.relY;

                const dx = (def.relX - bubble.width / 2);
                const dy = (def.relY - bubble.height / 2);
                const distanceToCenter = Math.sqrt(dx*dx + dy*dy);
                if (distanceToCenter > 0) {
                    handleAbsX_unrotated += (dx / distanceToCenter) * TAIL_SELECTION_HANDLE_OUTER_OFFSET;
                    handleAbsY_unrotated += (dy / distanceToCenter) * TAIL_SELECTION_HANDLE_OUTER_OFFSET;
                }

                // Rotate the handle position around the bubble's center
                const rotatedHandle = rotatePoint(
                    handleAbsX_unrotated,
                    handleAbsY_unrotated,
                    bubbleCenterX,
                    bubbleCenterY,
                    rotationAngle
                );

                // Convert rotated handle's image coordinates to canvas coordinates for hit testing
                const handleCanvas = toCanvasCoords(rotatedHandle.x, rotatedHandle.y);

                // Check if mouse is within the circular handle's area (on canvas)
                const dist = Math.sqrt(Math.pow(mouseX - handleCanvas.x, 2) + Math.pow(mouseY - handleCanvas.y, 2));
                if (dist < selHandleRadius) {
                    return {
                        index: selectedBubbleIndex,
                        tailPosition: def.assignedTailPos, // The side/corner the tail will *attach* to
                        tailTipImageX: rotatedHandle.x,      // The exact image X of the clicked handle (for initial tip position)
                        tailTipImageY: rotatedHandle.y       // The exact image Y of the clicked handle (for initial tip position)
                    };
                }
            }
            return null;
        }


        // --- Event Handlers ---

        /** Handles mouse down events on the canvas. */
        canvas.addEventListener('mousedown', (e) => {
            const mouseX = e.offsetX;
            const mouseY = e.offsetY;

            // Prioritize tail direction handle hit (click to change side and set initial tip)
            const tailDirHitResult = hitTestTailDirectionHandle(mouseX, mouseY);
            if (tailDirHitResult) {
                selectedBubbleIndex = tailDirHitResult.index;
                const bubble = speechBubbles[selectedBubbleIndex];
                bubble.tailPosition = tailDirHitResult.tailPosition; // Set the base side/corner
                // Set the tail tip to the exact location of the clicked handle (in image coords)
                // This ensures the tip is aligned with the handle you clicked
                const imageCoordsForHandle = toImageCoords(
                    toCanvasCoords(bubble.x, bubble.y).x + (tailDirHitResult.tailTipImageX - bubble.x) * scale,
                    toCanvasCoords(bubble.x, bubble.y).y + (tailDirHitResult.tailTipImageY - bubble.y) * scale
                );
                bubble.tailTipRelativeX = imageCoordsForHandle.x - bubble.x;
                bubble.tailTipRelativeY = imageCoordsForHandle.y - bubble.y;


                mode = 'moving-tail-handle'; // Immediately switch to allow dragging the new tail tip
                selectedHandle = 'tail';
                canvas.classList.remove('dragging-mode', 'drawing-mode', 'drawing-arrow-mode', 'resizing-mode');
                canvas.classList.add('moving-handle'); // Change cursor to move
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                updateDebugInfo();
                draw();
                return;
            }

            // Prioritize tail handle hit (drag the tip) - this should remain below tailDirHitResult check
            const isTailHandleHit = selectedBubbleIndex !== -1 && hitTestTailHandle(mouseX, mouseY);
            if (isTailHandleHit) {
                mode = 'moving-tail-handle';
                selectedHandle = 'tail';
                canvas.classList.remove('dragging-mode', 'drawing-mode', 'drawing-arrow-mode', 'resizing-mode');
                canvas.classList.add('moving-handle');
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                updateDebugInfo();
                return;
            }

            // Prioritize resize handle hit
            if (selectedBubbleIndex !== -1 && hitTestResizeHandle(mouseX, mouseY)) {
                mode = 'resizing';
                canvas.classList.remove('dragging-mode', 'drawing-mode', 'drawing-arrow-mode', 'moving-handle');
                canvas.classList.add('resizing-mode');
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                updateDebugInfo();
                return;
            }

            // Prioritize arrow handle hit WITH Ctrl key (Updated No Longer Need Ctrl Key To Match Bubble Mods)
            const { index: arrowHandleIndex, handle: arrowHandleType } = hitTestArrowHandle(mouseX, mouseY);
            if (arrowHandleIndex !== -1 /* && e.ctrlKey */) {
                selectedArrowIndex = arrowHandleIndex;
                selectedHandle = arrowHandleType;
                mode = 'moving-handle';
                canvas.classList.remove('dragging-mode', 'drawing-mode', 'drawing-arrow-mode', 'resizing-mode');
                canvas.classList.add('moving-handle');
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                draw();
                updateDebugInfo();
                return;
            }

            // Check for existing bubble hit
            const bubbleHitIndex = hitTestSpeechBubble(mouseX, mouseY);
            if (bubbleHitIndex !== -1) {
                selectedBubbleIndex = bubbleHitIndex;
                mode = 'dragging';
                canvas.classList.remove('drawing-mode', 'drawing-arrow-mode', 'resizing-mode', 'moving-handle');
                canvas.classList.add('dragging-mode');
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                updateDebugInfo();
                draw(); // Redraw to highlight selected bubble
                return;
            }

            // Check for existing arrow line/text hit (only if not handle and not ctrl key)
            const arrowHitIndex = hitTestArrowLine(mouseX, mouseY);
            if (arrowHitIndex !== -1) {
                selectedArrowIndex = arrowHitIndex;
                mode = 'dragging'; // Dragging the whole arrow
                canvas.classList.remove('drawing-mode', 'drawing-arrow-mode', 'resizing-mode', 'moving-handle');
                canvas.classList.add('dragging-mode');
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                updateDebugInfo();
                draw(); // Redraw to highlight selected arrow
                return;
            }

            // If no bubble or arrow hit, deselect and start panning or drawing
            selectedBubbleIndex = -1;
            selectedArrowIndex = -1;
            currentDrawingBubble = null;
            currentDrawingArrow = null;
            selectedHandle = null; // Clear selected handle
            updateDebugInfo();
            draw(); // Redraw to remove selection highlights


            if (mode === 'drawing') {
                const imageCoords = toImageCoords(mouseX, mouseY);
                currentDrawingBubble = {
                    x: imageCoords.x,
                    y: imageCoords.y,
                    width: 0,
                    height: 0,
                    text: '',
                    fontSize: 24,
                    fontFamily: 'Arial',
                    rotation: 0,
                    fillColor: '#FFFFFF',
                    fillAlpha: 1, // Default alpha
                    borderColor: '#000000',
                    borderAlpha: 1, // Default alpha
                    borderWidth: 2,
                    textColor: '#000000',
                    tailPosition: 'bottom-mid', // Default to bottom-mid
                    tailSize: 30, // Default tail base width and initial length
                    paddingX: 20,
                    paddingY: 20,
                    cornerRadius: 10,
                    isTextFlipped: false,
                    // tailTipRelativeX and Y will be initialized on mouseup when bubble has dimensions
                    tailTipRelativeX: 0, // Placeholder, will be updated on mouseup
                    tailTipRelativeY: 0, // Placeholder, will be updated on mouseup
                };
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            } else if (mode === 'drawing-arrow') {
                const imageCoords = toImageCoords(mouseX, mouseY);
                currentDrawingArrow = {
                    startX: imageCoords.x,
                    startY: imageCoords.y,
                    endX: imageCoords.x,
                    endY: imageCoords.y,
                    color: '#FF0000',
                    width: 5,
                    headSize: 15,
                    style: 'solid',
                    text: '',
                    fontSize: 16,
                    fontFamily: 'Arial',
                    textColor: '#000000',
                    textBgColor: '#FFFFFF', // Default text background color
                    textBgAlpha: 0.8,      // Default text background transparency
                    paddingX: 10,
                    paddingY: 10,
                    isTextFlipped: false
                };
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            } else if (e.shiftKey) { // Panning now requires Shift key
                mode = 'panning';
                isDraggingCanvas = true;
                canvas.classList.remove('drawing-mode', 'drawing-arrow-mode', 'resizing-mode', 'moving-handle');
                canvas.classList.add('dragging-mode');
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            } else {
                mode = 'idle';
                isDraggingCanvas = false;
                canvas.classList.remove('dragging-mode', 'resizing-mode', 'moving-handle', 'drawing-mode', 'drawing-arrow-mode', 'tail-direction-handle');
                canvas.style.cursor = 'grab';
            }
            updateDebugInfo();
        });

        /** Handles mouse move events on the canvas. */
        canvas.addEventListener('mousemove', (e) => {
            const mouseX = e.offsetX;
            const mouseY = e.offsetY;

            if (mode === 'panning' && isDraggingCanvas) {
                offsetX += (mouseX - lastMouseX);
                offsetY += (mouseY - lastMouseY);
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                draw();
            } else if (mode === 'drawing' && currentDrawingBubble) {
                const startImageCoords = toImageCoords(lastMouseX, lastMouseY);
                const currentImageCoords = toImageCoords(mouseX, mouseY);
                currentDrawingBubble.width = Math.abs(currentImageCoords.x - startImageCoords.x);
                currentDrawingBubble.height = Math.abs(currentImageCoords.y - startImageCoords.y);
                currentDrawingBubble.x = Math.min(startImageCoords.x, currentImageCoords.x);
                currentDrawingBubble.y = Math.min(startImageCoords.y, currentImageCoords.y);
                draw();
            } else if (mode === 'dragging' && selectedBubbleIndex !== -1) {
                const bubble = speechBubbles[selectedBubbleIndex];
                const deltaX = (mouseX - lastMouseX) / scale;
                const deltaY = (mouseY - lastMouseY) / scale;
                bubble.x += deltaX;
                bubble.y += deltaY;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                draw();
            } else if (mode === 'resizing' && selectedBubbleIndex !== -1) {
                const bubble = speechBubbles[selectedBubbleIndex];
                const deltaX = (mouseX - lastMouseX) / scale;
                const deltaY = (mouseY - lastMouseY) / scale;
                bubble.width += deltaX;
                bubble.height += deltaY;
                bubble.width = Math.max(10, bubble.width);
                bubble.height = Math.max(10, bubble.height);
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                draw();
            } else if (mode === 'drawing-arrow' && currentDrawingArrow) {
                const imageCoords = toImageCoords(mouseX, mouseY);
                currentDrawingArrow.endX = imageCoords.x;
                currentDrawingArrow.endY = imageCoords.y;
                draw();
            } else if (mode === 'moving-handle' && selectedArrowIndex !== -1 && selectedHandle) {
                const arrow = arrows[selectedArrowIndex];
                const imageCoords = toImageCoords(mouseX, mouseY);
                if (selectedHandle === 'start') {
                    arrow.startX = imageCoords.x;
                    arrow.startY = imageCoords.y;
                } else if (selectedHandle === 'end') {
                    arrow.endX = imageCoords.x;
                    arrow.endY = imageCoords.y;
                }
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                draw();
            } else if (mode === 'dragging' && selectedArrowIndex !== -1) {
                const arrow = arrows[selectedArrowIndex];
                const deltaX = (mouseX - lastMouseX) / scale;
                const deltaY = (mouseY - lastMouseY) / scale;
                arrow.startX += deltaX;
                arrow.startY += deltaY;
                arrow.endX += deltaX;
                arrow.endY += deltaY;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                draw();
            } else if (mode === 'moving-tail-handle' && selectedBubbleIndex !== -1 && selectedHandle === 'tail') {
                const bubble = speechBubbles[selectedBubbleIndex];
                const currentImageCoords = toImageCoords(mouseX, mouseY);

                // Get the bubble's center (in image coordinates)
                const bubbleCenterX = bubble.x + bubble.width / 2;
                const bubbleCenterY = bubble.y + bubble.height / 2;

                // Transform the current mouse position (absolute image coords)
                // back into the bubble's *unrotated* local coordinate system, relative to its center.
                // Then, calculate the relative offset from the bubble's (x,y)
                const angle = -bubble.rotation * Math.PI / 180; // Invert rotation for transformation
                const rotatedMousePoint = rotatePoint(
                    currentImageCoords.x,
                    currentImageCoords.y,
                    bubbleCenterX,
                    bubbleCenterY,
                    angle
                );

                bubble.tailTipRelativeX = rotatedMousePoint.x - bubble.x;
                bubble.tailTipRelativeY = rotatedMousePoint.y - bubble.y;

                lastMouseX = mouseX;
                lastMouseY = mouseY;
                draw();
            }


            // Update cursor based on hover
            if (mode === 'idle') {
                if (selectedBubbleIndex !== -1 && hitTestTailDirectionHandle(mouseX, mouseY)) {
                    canvas.classList.remove('dragging-mode', 'drawing-mode', 'drawing-arrow-mode', 'resizing-mode', 'moving-handle');
                    canvas.classList.add('tail-direction-handle');
                } else if (selectedBubbleIndex !== -1 && hitTestTailHandle(mouseX, mouseY)) {
                    canvas.classList.remove('drawing-mode', 'dragging-mode', 'drawing-arrow-mode', 'resizing-mode', 'tail-direction-handle');
                    canvas.classList.add('moving-handle');
                } else if (selectedBubbleIndex !== -1 && hitTestResizeHandle(mouseX, mouseY)) {
                    canvas.classList.remove('drawing-mode', 'dragging-mode', 'drawing-arrow-mode', 'moving-handle', 'tail-direction-handle');
                    canvas.classList.add('resizing-mode');
                } else if (hitTestArrowHandle(mouseX, mouseY).index !== -1 && e.ctrlKey) {
                    canvas.classList.remove('drawing-mode', 'dragging-mode', 'drawing-arrow-mode', 'resizing-mode', 'tail-direction-handle');
                    canvas.classList.add('moving-handle');
                } else if (hitTestSpeechBubble(mouseX, mouseY) !== -1 || hitTestArrowLine(mouseX, mouseY) !== -1) {
                    canvas.classList.remove('drawing-mode', 'drawing-arrow-mode', 'resizing-mode', 'moving-handle', 'tail-direction-handle');
                    canvas.classList.add('dragging-mode');
                } else if (e.shiftKey) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.classList.remove('drawing-mode', 'dragging-mode', 'resizing-mode', 'drawing-arrow-mode', 'moving-handle', 'tail-direction-handle');
                    canvas.style.cursor = 'grab';
                }
            }
        });

        /** Handles mouse up events on the canvas. */
        canvas.addEventListener('mouseup', () => {
            if (mode === 'drawing' && currentDrawingBubble) {
                if (currentDrawingBubble.width > 0 && currentDrawingBubble.height > 0) {
                    // Initialize tailTipRelativeX/Y for the newly created bubble
                    const bubble = currentDrawingBubble;
                    // Default tail position to bottom-mid initially, and initial tip slightly below
                    bubble.tailTipRelativeX = bubble.width / 2;
                    bubble.tailTipRelativeY = bubble.height + 30; // 30 pixels below bottom edge


                    speechBubbles.push(bubble);
                    selectedBubbleIndex = speechBubbles.length - 1;
                    // Populate modal fields for the newly created bubble
                    speechBubbleTextInput.value = bubble.text;
                    bubbleFontSizeInput.value = bubble.fontSize;
                    bubbleFontFamilySelect.value = bubble.fontFamily;
                    bubbleRotationInput.value = bubble.rotation;
                    bubbleFillColorInput.value = bubble.fillColor;
                    bubbleFillAlphaInput.value = bubble.fillAlpha;
                    bubbleBorderColorInput.value = bubble.borderColor;
                    bubbleBorderAlphaInput.value = bubble.borderAlpha;
                    bubbleBorderWidthInput.value = bubble.borderWidth;
                    bubbleTextColorInput.value = bubble.textColor;
                    bubbleTailSizeInput.value = bubble.tailSize;
                    bubblePaddingXInput.value = bubble.paddingX;
                    bubblePaddingYInput.value = bubble.paddingY;
                    bubbleCornerRadiusInput.value = bubble.cornerRadius;
                    bubbleFlipTextCheckbox.checked = bubble.isTextFlipped;
                    showSpeechBubbleEditModal();
                } else {
                    showMessage("Notice", "Speech bubble was too small and was not added.");
                }
                currentDrawingBubble = null; // Reset for next drawing action
            } else if (mode === 'drawing-arrow' && currentDrawingArrow) {
                 if (Math.abs(currentDrawingArrow.endX - currentDrawingArrow.startX) > 5 ||
                    Math.abs(currentDrawingArrow.endY - currentDrawingArrow.startY) > 5) {
                    arrows.push(currentDrawingArrow);
                    selectedArrowIndex = arrows.length - 1;
                    // Populate modal fields for the newly created arrow
                    arrowTextInput.value = currentDrawingArrow.text;
                    arrowColorInput.value = currentDrawingArrow.color;
                    arrowWidthInput.value = currentDrawingArrow.width;
                    arrowHeadSizeInput.value = currentDrawingArrow.headSize;
                    arrowStyleSelect.value = currentDrawingArrow.style;
                    arrowFontSizeInput.value = currentDrawingArrow.fontSize;
                    arrowFontFamilySelect.value = currentDrawingArrow.fontFamily;
                    arrowTextColorInput.value = currentDrawingArrow.textColor;
                    arrowTextBgColorInput.value = currentDrawingArrow.textBgColor;
                    arrowTextBgAlphaInput.value = currentDrawingArrow.textBgAlpha;
                    arrowPaddingXInput.value = currentDrawingArrow.paddingX;
                    arrowPaddingYInput.value = currentDrawingArrow.paddingY;
                    arrowFlipTextCheckbox.checked = currentDrawingArrow.isTextFlipped;
                    showArrowEditModal();
                    //showMessage("Saved", "Arrow added. You can now add text to it!");
                } else {
                    showMessage("Notice", "Arrow was too short and was not added.");
                }
                currentDrawingArrow = null; // Reset for next drawing action
            } else if (mode === 'moving-tail-handle') {
                selectedHandle = null; // Clear selected handle
            }

            mode = 'idle'; // Reset mode after any interaction
            isDraggingCanvas = false;
            canvas.classList.remove('drawing-mode', 'dragging-mode', 'resizing-mode', 'drawing-arrow-mode', 'moving-handle', 'tail-direction-handle');
            canvas.style.cursor = 'grab'; // Default cursor
            selectedHandle = null;
            updateDebugInfo();
            draw();
        });

        /** Handles double click events on the canvas to edit speech bubbles. */
        canvas.addEventListener('dblclick', (e) => {
            const mouseX = e.offsetX;
            const mouseY = e.offsetY;
            const bubbleHitIndex = hitTestSpeechBubble(mouseX, mouseY);
            if (bubbleHitIndex !== -1) {
                selectedBubbleIndex = bubbleHitIndex;
                const bubble = speechBubbles[selectedBubbleIndex];
                speechBubbleModalTitle.textContent = "Edit Speech Bubble";
                speechBubbleTextInput.value = bubble.text;
                bubbleFontSizeInput.value = bubble.fontSize;
                bubbleFontFamilySelect.value = bubble.fontFamily;
                bubbleRotationInput.value = bubble.rotation;
                bubbleFillColorInput.value = bubble.fillColor;
                bubbleFillAlphaInput.value = bubble.fillAlpha;
                bubbleBorderColorInput.value = bubble.borderColor;
                bubbleBorderAlphaInput.value = bubble.borderAlpha;
                bubbleBorderWidthInput.value = bubble.borderWidth;
                bubbleTextColorInput.value = bubble.textColor;
                bubbleTailSizeInput.value = bubble.tailSize;
                bubblePaddingXInput.value = bubble.paddingX;
                bubblePaddingYInput.value = bubble.paddingY;
                bubbleCornerRadiusInput.value = bubble.cornerRadius;
                bubbleFlipTextCheckbox.checked = bubble.isTextFlipped;
                showSpeechBubbleEditModal();
                updateDebugInfo();
            } else {
                const { index: arrowHandleIndex, handle: arrowHandleType } = hitTestArrowHandle(mouseX, mouseY);
                const arrowLineHitIndex = hitTestArrowLine(mouseX, mouseY);

                // Prioritize arrow handle hit over line hit for double-click if both apply
                if (arrowHandleIndex !== -1 || arrowLineHitIndex !== -1) {
                    selectedArrowIndex = arrowHandleIndex !== -1 ? arrowHandleIndex : arrowLineHitIndex;
                    const arrow = arrows[selectedArrowIndex];
                    arrowTextInput.value = arrow.text;
                    arrowColorInput.value = arrow.color;
                    arrowWidthInput.value = arrow.width;
                    arrowHeadSizeInput.value = arrow.headSize;
                    arrowStyleSelect.value = arrow.style;
                    arrowFontSizeInput.value = arrow.fontSize;
                    arrowFontFamilySelect.value = arrow.fontFamily;
                    arrowTextColorInput.value = arrow.textColor;
                    arrowTextBgColorInput.value = arrow.textBgColor;
                    arrowTextBgAlphaInput.value = arrow.textBgAlpha;
                    arrowPaddingXInput.value = arrow.paddingX;
                    arrowPaddingYInput.value = arrow.paddingY;
                    arrowFlipTextCheckbox.checked = arrow.isTextFlipped;
                    showArrowEditModal();
                    updateDebugInfo();
                } else {
                    selectedBubbleIndex = -1;
                    selectedArrowIndex = -1;
                    updateDebugInfo();
                    draw();
                }
            }
        });


        /** Handles mouse wheel events for zooming. */
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // Prevent page scrolling
            const mouseX = e.offsetX;
            const mouseY = e.offsetY;

            const scaleAmount = 1.1; // Zoom in/out factor
            const oldScale = scale;

            if (e.deltaY < 0) { // Zoom in
                scale *= scaleAmount;
            } else { // Zoom out
                scale /= scaleAmount;
            }

            // Limit zoom
            scale = Math.max(0.1, Math.min(10, scale));

            // Adjust offset to zoom into/out of mouse position
            offsetX = mouseX - ((mouseX - offsetX) / oldScale) * scale;
            offsetY = mouseY - ((mouseY - offsetY) / oldScale) * scale;

            zoomLevelSpan.textContent = `${Math.round(scale * 100)}%`;
            draw();
        });


        // --- Button Event Listeners ---

        /** Handles custom image upload button click. */
        customImageUploadBtn.addEventListener('click', () => {
            imageUpload.click(); // Trigger the hidden file input click
        });

        /** Handles image file selection. */
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                fileNameDisplay.textContent = file.name;
                const reader = new FileReader();
                reader.onload = (event) => {
                    backgroundImage.onload = () => {
                        // Reset pan and zoom when new image is loaded
                        offsetX = 0;
                        offsetY = 0;
                        scale = 1;
                        zoomLevelSpan.textContent = '100%';
                        speechBubbles = []; // Clear existing bubbles
                        arrows = []; // Clear existing arrows
                        selectedBubbleIndex = -1;
                        selectedArrowIndex = -1;
                        updateDebugInfo();
                        draw(); // Redraw canvas with new image
                    };
                    backgroundImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
                imageUpload.value = '';
            } else {
                fileNameDisplay.textContent = 'No file chosen';
                backgroundImage = new Image(); // Clear image if no file selected
                speechBubbles = [];
                arrows = [];
                draw();
            }
        });

        /** Initiates speech bubble drawing mode. */
        createSpeechBubbleBtn.addEventListener('click', () => {
            mode = 'drawing';
            selectedBubbleIndex = -1; // Deselect any existing bubble
            selectedArrowIndex = -1; // Deselect any existing arrow
            canvas.classList.remove('dragging-mode', 'resizing-mode', 'drawing-arrow-mode', 'moving-handle', 'tail-direction-handle');
            canvas.classList.add('drawing-mode'); // Change cursor
            updateDebugInfo();
            showMessage("Draw Mode", "Click and drag on the canvas to draw a speech bubble.");
        });

        /** Initiates arrow drawing mode. */
        createArrowBtn.addEventListener('click', () => {
            mode = 'drawing-arrow';
            selectedBubbleIndex = -1; // Deselect any existing bubble
            selectedArrowIndex = -1; // Deselect any existing arrow
            canvas.classList.remove('dragging-mode', 'resizing-mode', 'drawing-mode', 'moving-handle', 'tail-direction-handle');
            canvas.classList.add('drawing-arrow-mode'); // Change cursor
            updateDebugInfo();
            showMessage("Draw Arrow Mode", "Click and drag on the canvas to draw an arrow.");
        });

        /** Saves the edited image. */
		saveImageBtn.addEventListener('click', function () {
			const exportCanvas = document.createElement('canvas');
			const exportCtx = exportCanvas.getContext('2d');

			if (saveImageWithinBoundsCheckbox.checked && backgroundImage.src) {
				exportCanvas.width = backgroundImage.width;
				exportCanvas.height = backgroundImage.height;

				const originalOffsetX = offsetX;
				const originalOffsetY = offsetY;
				const originalScale = scale;
				const originalCtx = ctx;

				offsetX = 0;
				offsetY = 0;
				scale = 1;
				ctx = exportCtx; // ✅ Temporarily switch to export context

				draw(); // ✅ Use your same draw() function

				ctx = originalCtx; // ✅ Restore original context
				offsetX = originalOffsetX;
				offsetY = originalOffsetY;
				scale = originalScale;

			} else {
				exportCanvas.width = canvas.width;
				exportCanvas.height = canvas.height;
				exportCtx.drawImage(canvas, 0, 0);
			}

			const dataURL = exportCanvas.toDataURL('image/png');
			const link = document.createElement('a');
			link.download = 'bubbleup.png';
			link.href = dataURL;
			link.click();
		});




        /** Displays the 'How To Use' instructions. */
        howToBtn.addEventListener('click', () => {
            showMessage(
                "How To Use",
                `
                <p>1. <b>Upload Image:</b> Click "Choose Image" to select a background image.</p>
                <p>2. <b>Create Speech Bubble:</b> Click "Create Speech Bubble", then click and drag on the canvas to draw a bubble. Double-click the bubble to edit its text and appearance.</p>
                <p>3. <b>Create Stretchable Arrow:</b> Click "Create Stretchable Arrow", then click and drag to draw an arrow. Double-click the arrow to edit its appearance.</p>
                <p>4. <b>Move Elements:</b> Click and drag any existing bubble or arrow to move it.</p>
                <p>5. <b>Resize Bubbles:</b> Click a bubble to select it, then drag the <b>red square handle</b> at its bottom-right corner to resize.</p>
                <p>6. <b>Pan Canvas:</b> Hold down the <b>Shift key</b> and click and drag on an empty area of the canvas to pan the view.</p>
                <p>7. <b>Move Arrow Handles:</b> Hold down the <b>Ctrl key</b> and drag either end handle of an arrow to resize/reposition it.</p>
                <p>8. <b>Move Bubble Tail:</b> Select a speech bubble, and then drag the <b>red circular handle</b> at the tip of its tail to reposition it.</p>
                <p>9. <b>Change Tail Origin:</b> When a speech bubble is selected, click one of the <b>eight large blue circular handles</b> (4 on the sides, 4 on the corners) around the bubble to change where the tail originates from. After clicking, you can drag the red circular tail tip handle to fine-tune its position.</p>
                <p>10. <b>Zoom:</b> Use your mouse wheel or the +/- buttons to zoom in/out. Click "Reset" to return to 100% zoom.</p>
                <p>11. <b>Save Image:</b> Click "Save Edited Image" to download your creation as a PNG.</p>
                <p>12. <b>Clear Canvas:</b> Click "Clear Canvas" to remove all elements and the background image.</p>
                `
            );
        });

        /** Clears the canvas, removing image, bubbles, and arrows. */
        clearCanvasBtn.addEventListener('click', () => {
            backgroundImage = new Image();
            speechBubbles = [];
            arrows = [];
            offsetX = 0;
            offsetY = 0;
            scale = 1;
            zoomLevelSpan.textContent = '100%';
            selectedBubbleIndex = -1;
            selectedArrowIndex = -1;
            fileNameDisplay.textContent = 'No file chosen';
            imageUpload.value = '';
            updateDebugInfo();
            draw();
            showMessage("Canvas Cleared", "All elements and background image have been removed.");
        });

        /** Zooms in on the canvas. */
        zoomInBtn.addEventListener('click', () => {
            const oldScale = scale;
            scale *= 1.1;
            scale = Math.min(10, scale);
            offsetX = canvas.width / 2 - ((canvas.width / 2 - offsetX) / oldScale) * scale;
            offsetY = canvas.height / 2 - ((canvas.height / 2 - offsetY) / oldScale) * scale;
            zoomLevelSpan.textContent = `${Math.round(scale * 100)}%`;
            draw();
        });

        /** Zooms out on the canvas. */
        zoomOutBtn.addEventListener('click', () => {
            const oldScale = scale;
            scale /= 1.1;
            scale = Math.max(0.1, scale);
            offsetX = canvas.width / 2 - ((canvas.width / 2 - offsetX) / oldScale) * scale;
            offsetY = canvas.height / 2 - ((canvas.height / 2 - offsetY) / oldScale) * scale;
            zoomLevelSpan.textContent = `${Math.round(scale * 100)}%`;
            draw();
        });

        /** Resets canvas zoom and pan. */
        resetZoomBtn.addEventListener('click', () => {
            offsetX = 0;
            offsetY = 0;
            scale = 1;
            zoomLevelSpan.textContent = '100%';
            draw();
            showMessage("Zoom Reset", "Canvas zoom and pan have been reset.");
        });

        // --- Speech Bubble Modal Button Listeners ---

        /** Saves changes to the speech bubble from the modal. */
        saveSpeechBubbleBtn.addEventListener('click', () => {
            if (selectedBubbleIndex !== -1) {
                const bubble = speechBubbles[selectedBubbleIndex];

                bubble.text = speechBubbleTextInput.value;
                bubble.fontSize = parseInt(bubbleFontSizeInput.value);
                bubble.fontFamily = bubbleFontFamilySelect.value;
                bubble.rotation = parseFloat(bubbleRotationInput.value);
                bubble.isTextFlipped = bubbleFlipTextCheckbox.checked;
                
                bubble.fillColor = bubbleFillColorInput.value;
                bubble.fillAlpha = parseFloat(bubbleFillAlphaInput.value); // Save fill alpha
                bubble.borderColor = bubbleBorderColorInput.value;
                bubble.borderAlpha = parseFloat(bubbleBorderAlphaInput.value); // Save border alpha
                bubble.borderWidth = parseInt(bubbleBorderWidthInput.value);
                bubble.textColor = bubbleTextColorInput.value;
                bubble.tailSize = parseInt(bubbleTailSizeInput.value);
                bubble.paddingX = parseInt(bubblePaddingXInput.value);
                bubble.paddingY = parseInt(bubblePaddingYInput.value);
                bubble.cornerRadius = parseInt(bubbleCornerRadiusInput.value);

                showMessage("Saved", "Speech bubble updated.");
            } else {
                 showMessage("Error", "No speech bubble selected to save.");
            }
            hideSpeechBubbleEditModal();
            selectedBubbleIndex = -1; // Deselect after editing
            mode = 'idle';
            updateDebugInfo();
            draw();
        });

        /** Cancels changes and hides the speech bubble modal. */
        cancelSpeechBubbleBtn.addEventListener('click', () => {
            hideSpeechBubbleEditModal();
            currentDrawingBubble = null; // Ensure this is cleared
            selectedBubbleIndex = -1; // Deselect after canceling
            mode = 'idle';
            updateDebugInfo();
            draw();
            showMessage("Cancelled", "Speech bubble editing cancelled.");
        });

        /** Deletes the currently selected speech bubble. */
        deleteSpeechBubbleBtn.addEventListener('click', () => {
            if (selectedBubbleIndex !== -1) {
                speechBubbles.splice(selectedBubbleIndex, 1);
                showMessage("Success", "Speech bubble deleted.");
            } else {
                showMessage("Error", "No speech bubble selected for deletion.");
            }
            hideSpeechBubbleEditModal();
            currentDrawingBubble = null;
            selectedBubbleIndex = -1;
            mode = 'idle';
            updateDebugInfo();
            draw();
        });

        // --- Arrow Modal Button Listeners ---

        /** Saves changes to the arrow from the modal. */
        saveArrowBtn.addEventListener('click', () => {
            if (selectedArrowIndex !== -1) { // Operate directly on the selected arrow
                const arrow = arrows[selectedArrowIndex];
                arrow.text = arrowTextInput.value;
                arrow.color = arrowColorInput.value;
                arrow.width = parseInt(arrowWidthInput.value);
                arrow.headSize = parseInt(arrowHeadSizeInput.value);
                arrow.style = arrowStyleSelect.value;
                arrow.fontSize = parseInt(arrowFontSizeInput.value);
                arrow.fontFamily = arrowFontFamilySelect.value;
                arrow.textColor = arrowTextColorInput.value;
                arrow.textBgColor = arrowTextBgColorInput.value; // Save text background color
                arrow.textBgAlpha = parseFloat(arrowTextBgAlphaInput.value); // Save text background transparency
                arrow.paddingX = parseInt(arrowPaddingXInput.value);
                arrow.paddingY = parseInt(arrowPaddingYInput.value);
                arrow.isTextFlipped = arrowFlipTextCheckbox.checked;
                showMessage("Saved", "Arrow updated.");
            } else {
                showMessage("Error", "No arrow selected to save.");
            }
            hideArrowEditModal();
            selectedArrowIndex = -1; // Deselect after editing
            mode = 'idle';
            updateDebugInfo();
            draw();
        });

        /** Cancels changes and hides the arrow modal. */
        cancelArrowBtn.addEventListener('click', () => {
            hideArrowEditModal();
            currentDrawingArrow = null; // Ensure this is cleared
            selectedArrowIndex = -1; // Deselect after canceling
            mode = 'idle';
            updateDebugInfo();
            draw();
            showMessage("Cancelled", "Arrow editing cancelled.");
        });

        /** Deletes the currently selected arrow. */
        deleteArrowBtn.addEventListener('click', () => {
            if (selectedArrowIndex !== -1) {
                arrows.splice(selectedArrowIndex, 1);
                showMessage("Success", "Arrow deleted.");
            } else {
                showMessage("Error", "No arrow selected for deletion.");
            }
            hideArrowEditModal();
            currentDrawingArrow = null;
            selectedArrowIndex = -1;
            mode = 'idle';
            updateDebugInfo();
            draw();
        });


        /** Closes the general message modal. */
        closeMessageModalBtn.addEventListener('click', hideMessage);

        // --- Initial Setup and Event Listeners ---

        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        window.addEventListener('DOMContentLoaded', () => {
             draw(); // Initial draw
             updateDebugInfo();
        });
    </script>
</body>
</html>
