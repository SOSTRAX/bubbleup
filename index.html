<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Image Editor</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Apply Inter font family */
        body {
            font-family: 'Inter', sans-serif;
            opacity: 0; /* Initially hide the body to prevent FOUC */
            transition: opacity 0.3s ease-in-out; /* Smooth fade-in */
        }

        /* Pointer animation styles */
        .pointer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pointer-pointer {
            width: 100px;
            height: 100px;
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            animation: pointerPulse 1.5s infinite;
        }

        .pointer-pointer::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 20px solid #6366f1;
            transform: rotate(45deg);
            margin-top: -10px;
        }

        .pointer-text {
            position: absolute;
            top: 120px;
            text-align: center;
            font-size: 1.75rem;
            color: #6366f1;
            font-weight: 700;
            animation: fadeIn 1s ease-in-out;
            background: rgba(255, 255, 255, 0.95);
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        @keyframes pointerPulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.3);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        /* Custom styles for the canvas and layout */
        .container {
            display: flex;
            height: 100vh;
            overflow: hidden; /* Prevent body scroll */
        }
        .sidebar {
            width: 16rem; /* Reduced from 20rem */
            background-color: white;
            padding: 0.5rem; /* Reduced from 0.75rem */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.25rem; /* Reduced from 0.5rem */
        }
        .canvas-container {
            flex-grow: 1; /* Canvas takes remaining space */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #e5e7eb; /* Slightly darker background for canvas area */
            overflow: hidden; /* Prevent canvas container from scrolling */
            position: relative;
        }
        canvas {
            border: 1px solid #d1d5db; /* Light border for the canvas */
            background-color: #ffffff; /* White canvas background */
            touch-action: none; /* Prevent default touch actions like pan/zoom */
        }
        /* Styles for modals */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            height: 100%;
            width: 100%;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .modal-content {
            background-color: white;
            padding: 1rem;
            border-radius: 0.5rem; /* Rounded-lg */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); /* Shadow-2xl */
            width: 100%;
            max-width: 42rem; /* Max-w-3xl */
            max-height: 85vh; /* Set max height */
            overflow-y: auto; /* Enable scroll on overflow */
        }
        .form-group {
            margin-bottom: 0.25rem;
        }
        .form-group label {
            font-weight: 600;
            font-size: 0.75rem; /* Reduced from 0.875rem */
            color: #374151; /* Gray-700 */
        }
        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group input[type="color"],
        .form-group select {
            padding: 0.375rem 0.5rem; /* Reduced from 0.5rem 0.75rem */
            border: 1px solid #d1d5db; /* Gray-300 */
            border-radius: 0.375rem; /* Rounded-md */
            font-size: 0.875rem; /* Reduced from 1rem */
            line-height: 1.5;
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        .form-group input[type="text"]:focus,
        .form-group input[type="number"]:focus,
        .form-group input[type="color"]:focus,
        .form-group select:focus {
            border-color: #6366f1; /* Indigo-500 */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.25); /* Indigo-500 with opacity */
            outline: none;
        }
        /* Custom range input styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db; /* Gray-300 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366f1; /* Indigo-500 */
            cursor: pointer;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366f1; /* Indigo-500 */
            cursor: pointer;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4);
        }
    </style>
</head>
<body class="bg-gray-100">
    <div style="position: fixed; top: 5px; left: 10px; font-size: 11px; font-family: sans-serif; color: #555; z-index: 10000; /*pointer-events: none;*/">
      <a href="https://github.com/SOSTRAX/bubbleup">© 2025 Michael Dietz · SOSTRAX</a>
    </div>

    <!-- Hidden project/license/contact info -->
    <div style="display: none;">
      <section>
        <h2>About This Project</h2>
        <p><strong>Project:</strong> BubbleUp Image Editor</p>
        <p><strong>Author:</strong> Michael Dietz</p>
        <p>This project is a simple HTML page created to demonstrate the flexibility of the CANVAS.</p>
        <p><strong>License:</strong> MIT License — free to use with attribution. See https://opensource.org/licenses/MIT</p>
        <p>If you’re interested in working together or want to know more, feel free to contact me: mike@sostrax.com</p>
        <p>View this project on GitHub: https://github.com/SOSTRAX/bubbleup</p>
      </section>
    </div>

    <!-- Main Header -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 p-4 text-white shadow-lg z-10">
        <h1 class="text-3xl font-bold text-center">BubbleUp</h1>
    </header>
    <div class="container">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <!-- File Menu Dropdown -->
            <div class="relative" id="fileMenuContainer">
                <button id="fileMenuBtn" class="w-full bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out flex items-center justify-center">
                    <i class="fas fa-file-alt mr-2"></i>
                    <span>File</span>
                    <i class="fas fa-chevron-down ml-auto pl-2"></i>
                </button>
                <div id="fileMenuDropdown" class="absolute left-0 mt-2 w-full rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden z-20">
                    <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="fileMenuBtn">
                        <a href="#" id="exportToFileBtn" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem"><i class="fas fa-file-export mr-2"></i>Export Project (.json)</a>
                        <a href="#" id="importFromFileBtn" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem"><i class="fas fa-file-import mr-2"></i>Import Project (.json)</a>
                        <div class="border-t border-gray-200 my-1"></div>
                        <a href="#" id="saveImageBtn" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem"><i class="fas fa-save mr-2"></i>Save as Image (.png)</a>
                        <a href="#" id="saveClipBtn" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem"><i class="fas fa-video mr-2"></i>Save as Clip (.webm)</a>
                    </div>
                </div>
            </div>
            <input type="file" id="fileInput" class="hidden" accept=".json">
            <div class="border-t border-gray-300 my-2"></div>

            <!-- Pointer Elements -->
            <div id="saveCanvasPointer" class="pointer-overlay hidden">
                <div class="pointer-pointer"></div>
                <div class="pointer-text">Save Canvas</div>
            </div>
            <div id="loadCanvasPointer" class="pointer-overlay hidden">
                <div class="pointer-pointer"></div>
                <div class="pointer-text">Load Canvas</div>
            </div>


            <!-- Feature Buttons -->
            <button id="uploadImageBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                <i class="fas fa-upload mr-2"></i>Choose Image
            </button>
            <input type="file" id="imageInput" accept="image/*" class="hidden">
            <div id="fileNameDisplay" class="text-center text-sm text-blue-600 mt-2 font-medium bg-white px-3 py-1 rounded-full shadow-sm w-full"></div>

            <button id="createBubbleBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                <i class="fas fa-comment-dots mr-2"></i>Create Speech Bubble
            </button>
            <div id="bubblePointer" class="pointer-overlay hidden">
                <div class="pointer-pointer"></div>
                <div class="pointer-text">Drag To Place Bubble</div>
            </div>

            <button id="createArrowBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                <i class="fas fa-arrow-right mr-2"></i>Create Stretchable Arrow
            </button>
            <div id="arrowPointer" class="pointer-overlay hidden">
                <div class="pointer-pointer"></div>
                <div class="pointer-text">Drag To Make Arrow</div>
            </div>



            <button id="clearCanvasBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                <i class="fas fa-trash-alt mr-2"></i>Clear Canvas
            </button>

            <button id="howToBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                <i class="fas fa-info-circle mr-2"></i>How To Use
            </button>
            <div class="text-center text-xl text-blue-600 mt-4 font-bold">Double Click New Objects To Edit Properties</div>

            <div class="mt-4">
                <h2 class="text-sm font-semibold mb-1 text-gray-700">Canvas Controls</h2>
                <div class="flex flex-col gap-2">
                    <button id="zoomInBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                        <i class="fas fa-search-plus mr-2"></i>Zoom +
                    </button>
                    <button id="zoomOutBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                        <i class="fas fa-search-minus mr-2"></i>Zoom -
                    </button>
                    <button id="resetZoomBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
                        <i class="fas fa-compress-arrows-alt mr-2"></i>Reset
                    </button>
                    <div id="zoomLevelLabel" class="text-center text-sm text-gray-600 mt-2">Zoom: 100%</div>
                </div>
            </div>
        </div>

        <!-- Right Canvas Area -->
        <div class="canvas-container">
            <canvas id="myCanvas"></canvas>
        </div>
    </div>

    <!-- Speech Bubble Editor Modal -->
    <div id="bubbleEditorModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full z-50 flex items-center justify-center p-2">
        <div class="modal-content">
            <h2 class="text-lg font-bold mb-1 text-gray-800">Edit Speech Bubble</h2>
            <form class="mt-1 grid grid-cols-1 md:grid-cols-2 gap-x-2 gap-y-1">
                <div class="form-group">
                    <label for="bubbleText">Text String:</label>
                    <input type="text" id="bubbleText" class="w-full">
                </div>
                <div class="form-group">
                    <label for="bubbleFontSize">Font Size:</label>
                    <input type="number" id="bubbleFontSize" min="8" max="72" class="w-full">
                </div>
                <div class="form-group">
                    <label for="bubbleFont">Font Family:</label>
                    <select id="bubbleFont" class="w-full">
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                        <option value="Impact">Impact</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="bubbleFill">Fill Color:</label>
                    <input type="color" id="bubbleFill" class="w-full h-8">
                </div>
                <div class="form-group">
                    <label for="bubbleFillTransparency">Fill Transparency:</label>
                    <input type="range" id="bubbleFillTransparency" min="0" max="1" step="0.01" class="w-full">
                    <span id="bubbleFillTransparencyValue" class="text-xs text-gray-500 text-right"></span>
                </div>
                <div class="form-group">
                    <label for="bubbleBorderColor">Border Color:</label>
                    <input type="color" id="bubbleBorderColor" class="w-full h-8">
                </div>
                <div class="form-group">
                    <label for="bubbleBorderTransparency">Border Transparency:</label>
                    <input type="range" id="bubbleBorderTransparency" min="0" max="1" step="0.01" class="w-full">
                    <span id="bubbleBorderTransparencyValue" class="text-xs text-gray-500 text-right"></span>
                </div>
                <div class="form-group">
                    <label for="bubbleTextColor">Text Color:</label>
                    <input type="color" id="bubbleTextColor" class="w-full h-8">
                </div>
                <div class="form-group">
                    <label for="bubbleBorderWidth">Border Width:</label>
                    <input type="number" id="bubbleBorderWidth" min="0" max="20" class="w-full">
                </div>
                <div class="form-group">
                    <label for="bubbleTailSide">Tail Side:</label>
                    <select id="bubbleTailSide" class="w-full">
                        <option value="bottom">Bottom</option>
                        <option value="top">Top</option>
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="bubbleTailAlignment">Tail Alignment:</label>
                    <select id="bubbleTailAlignment" class="w-full">
                        <option value="center">Center</option>
                        <option value="start">Start</option>
                        <option value="end">End</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="bubblePaddingX">Padding X:</label>
                    <input type="number" id="bubblePaddingX" min="0" max="100" class="w-full">
                </div>
                <div class="form-group">
                    <label for="bubblePaddingY">Padding Y:</label>
                    <input type="number" id="bubblePaddingY" min="0" max="100" class="w-full">
                </div>
                <div class="form-group">
                    <label for="bubbleRotation">Rotation:</label>
                    <input type="number" id="bubbleRotation" min="-180" max="180" class="w-full">
                </div>
                <div class="form-group">
                    <label for="bubbleTailLength">Tail Length:</label>
                    <input type="number" id="bubbleTailLength" min="0" max="100" class="w-full">
                </div>
                <div class="form-group">
                    <label for="bubbleTailWidth">Tail Width:</label>
                    <input type="number" id="bubbleTailWidth" min="0" max="50" class="w-full">
                </div>
            </form>
            <div class="flex justify-end gap-1 mt-2">
                <button id="copyBubbleBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-2 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Copy Bubble
                </button>
                <button id="pasteBubbleBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-2 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Paste Bubble
                </button>
                <button id="deleteBubbleBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Delete Bubble
                </button>
                <button id="cancelBubbleBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Cancel
                </button>
                <button id="applyBubbleBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Apply Bubble
                </button>
            </div>
        </div>
    </div>

    <!-- Arrow Editor Modal -->
    <div id="arrowEditorModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="text-lg font-bold mb-2 text-gray-800">Edit Stretchable Arrow</h2>
            <form id="arrowForm" class="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2">
                <div class="form-group">
                    <label for="arrowText">Text String:</label>
                    <input type="text" id="arrowText" class="w-full">
                </div>
                <div class="form-group">
                    <label for="arrowFontSize">Font Size:</label>
                    <input type="number" id="arrowFontSize" min="8" max="100" class="w-full">
                </div>
                <div class="form-group">
                    <label for="arrowFontFamily">Font Family:</label>
                    <select id="arrowFontFamily" class="w-full">
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Palatino">Palatino</option>
                        <option value="Garamond">Garamond</option>
                        <option value="Trebuchet MS">Trebuchet MS</option>
                        <option value="Impact">Impact</option>
                        <option value="Inter">Inter</option>
                        <!-- Add more font options as needed -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="arrowRotation">Rotation (Degrees):</label>
                    <input type="number" id="arrowRotation" min="0" max="360" step="1" class="w-full">
                </div>
                <div class="form-group">
                    <label for="arrowFillColor">Line Color:</label>
                    <input type="color" id="arrowFillColor" class="w-full h-10">
                </div>
                <div class="form-group">
                    <label for="arrowFillTransparency">Line Transparency:</label>
                    <input type="range" id="arrowFillTransparency" min="0" max="1" step="0.01" class="w-full">
                    <span id="arrowFillTransparencyValue" class="text-xs text-gray-500 text-right"></span>
                </div>
                <div class="form-group">
                    <label for="arrowTextColor">Text Color:</label>
                    <input type="color" id="arrowTextColor" class="w-full h-10">
                </div>
                <div class="form-group">
                    <label for="arrowTextBackgroundColor">Text Background Color:</label>
                    <input type="color" id="arrowTextBackgroundColor" class="w-full h-10">
                </div>
                <div class="form-group">
                    <label for="arrowLineWidth">Line Width:</label>
                    <input type="number" id="arrowLineWidth" min="1" max="20" class="w-full">
                </div>
                <div class="form-group">
                    <label for="arrowHeadSize">Head Size:</label>
                    <input type="number" id="arrowHeadSize" min="5" max="50" class="w-full">
                </div>
                <div class="form-group">
                    <label for="arrowPaddingX">Padding X:</label>
                    <input type="number" id="arrowPaddingX" min="0" max="100" class="w-full">
                </div>
                <div class="form-group">
                    <label for="arrowPaddingY">Padding Y:</label>
                    <input type="number" id="arrowPaddingY" min="0" max="100" class="w-full">
                </div>
                <div class="form-group flex items-center justify-start mt-2">
                    <input type="checkbox" id="arrowFlipText" class="mr-2 h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                    <label for="arrowFlipText" class="mb-0">Flip Text 180 degrees</label>
                </div>
            </form>
            <div class="flex justify-end gap-2 mt-4">
                <button id="copyArrowBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Copy Arrow
                </button>
                <button id="pasteArrowBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1.5 px-3 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Paste Arrow
                </button>
                <button id="deleteArrowBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Delete Arrow
                </button>
                <button id="cancelArrowBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Cancel
                </button>
                <button id="applyArrowBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Apply Arrow
                </button>
            </div>
        </div>
    </div>

    <!-- How To Modal -->
    <div id="howToModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-4 text-gray-800">How To Use This Editor</h2>
            <div class="prose text-gray-700">
                <p>Welcome to the Canvas Image Editor! Here's how to get started:</p>
                <ul class="list-disc pl-5 space-y-2">
                    <li><strong>Upload Image:</strong> Click "Upload Image" to select a base image for editing.</li>
                    <li><strong>Create Speech Bubble:</strong> Click this button, then click and drag on the canvas to draw a new speech bubble.</li>
                    <li><strong>Create Stretchable Arrow:</strong> Click this button, then click and drag on the canvas to draw a new arrow.</li>
                    <li><strong>Edit Shapes:</strong> Double-click on any speech bubble or arrow to open its property editor. You can change text, colors, sizes, and more.</li>
                    <li><strong>Move Shapes:</strong> Click and drag any shape to reposition it on the canvas.</li>
                    <li><strong>Resize Shapes:</strong> Click on a shape to select it, then drag the small square handles that appear around its bounding box to resize.</li>
                    <li><strong>Move Speech Bubble Tail:</strong> For speech bubbles, click and drag the small circle handle at the tip of the tail to reposition it.</li>
                    <li><strong>Rotate Shapes:</strong> Hold down the <kbd>Ctrl</kbd> key, then click on a shape. Four circular rotation handles will appear outside the shape. Drag any of these handles to rotate the shape.</li>
                    <li><strong>Zoom:</strong> Use the "Zoom +" and "Zoom -" buttons to adjust the canvas view. "Zoom Reset" returns to the default view.</li>
                    <li><strong>Save Edited Image:</strong> Click to download your edited canvas as a PNG image.</li>
                    <li><strong>Clear Canvas:</strong> Clears all content from the canvas.</li>
                </ul>
                <p class="mt-4">Enjoy creating!</p>
            </div>
            <div class="flex justify-end mt-6">
                <button id="closeHowToBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Got It!
                </button>
            </div>
        </div>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="confirmModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-4 text-gray-800">Confirm Action</h2>
            <p id="confirmMessage" class="text-gray-700 mb-6">Are you sure you want to clear the canvas? This action cannot be undone.</p>
            <div class="flex justify-end gap-2">
                <button id="confirmCancelBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Cancel
                </button>
                <button id="confirmOkBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Confirm
                </button>
            </div>
        </div>
    </div>


    <script>
        // Global variables
        let isCtrlPressed = false;
        let uploadedImage = null; // Store the uploaded image

        // Get canvas and context
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        // --- Canvas State Variables ---
        let shapes = []; // Array to hold SpeechBubble and Arrow objects
        let selectedShape = null; // Currently selected shape for dragging/resizing/editing
        let drawingMode = null; // 'bubble' or 'arrow' or null
        let startX, startY; // Starting coordinates for drawing or dragging
        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null; // 'tl', 'tr', 'bl', 'br', 't', 'b', 'l', 'r'
        let isRotating = false;
        let rotationHandle = null; // 'rot1', 'rot2', 'rot3', 'rot4'
        let isTailMoving = false; // For speech bubble tail
        let lastMouseX, lastMouseY; // For dragging/panning

        let currentZoom = 1;
        const ZOOM_FACTOR = 1.1;
        let panX = 0;
        let panY = 0;


        // --- UI Elements ---
        const uploadImageBtn = document.getElementById('uploadImageBtn');
        const imageInput = document.getElementById('imageInput');
        const createBubbleBtn = document.getElementById('createBubbleBtn');
        const createArrowBtn = document.getElementById('createArrowBtn');
        const saveImageBtn = document.getElementById('saveImageBtn');
        const saveClipBtn = document.getElementById('saveClipBtn');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const howToBtn = document.getElementById('howToBtn');
        const howToModal = document.getElementById('howToModal');
        const closeHowToBtn = document.getElementById('closeHowToBtn');

        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');

        const bubbleEditorModal = document.getElementById('bubbleEditorModal');
        const bubbleForm = document.getElementById('bubbleForm');
        const bubbleText = document.getElementById('bubbleText');
        const bubbleFontSize = document.getElementById('bubbleFontSize');
        const bubbleFontFamily = document.getElementById('bubbleFontFamily');
        const bubbleRotation = document.getElementById('bubbleRotation');
        const bubbleFillColor = document.getElementById('bubbleFillColor');
        const bubbleFillTransparency = document.getElementById('bubbleFillTransparency');
        const bubbleFillTransparencyValue = document.getElementById('bubbleFillTransparencyValue');
        const bubbleBorderColor = document.getElementById('bubbleBorderColor');
        const bubbleBorderTransparency = document.getElementById('bubbleBorderTransparency');
        const bubbleBorderTransparencyValue = document.getElementById('bubbleBorderTransparencyValue');
        const bubbleBorderWidth = document.getElementById('bubbleBorderWidth');
        const bubbleTextColor = document.getElementById('bubbleTextColor');
        const bubbleTailSide = document.getElementById('bubbleTailSide'); // New
        const bubbleTailAlignment = document.getElementById('bubbleTailAlignment'); // New
        const bubbleTailBaseWidth = document.getElementById('bubbleTailBaseWidth');
        const bubblePaddingX = document.getElementById('bubblePaddingX');
        const bubblePaddingY = document.getElementById('bubblePaddingY');
        const bubbleCornerRadius = document.getElementById('bubbleCornerRadius');
        const bubbleFlipText = document.getElementById('bubbleFlipText');
        const deleteBubbleBtn = document.getElementById('deleteBubbleBtn');
        const cancelBubbleBtn = document.getElementById('cancelBubbleBtn');
        const applyBubbleBtn = document.getElementById('applyBubbleBtn');

        const arrowEditorModal = document.getElementById('arrowEditorModal');
        const arrowForm = document.getElementById('arrowForm');
        const arrowText = document.getElementById('arrowText');
        const arrowFontSize = document.getElementById('arrowFontSize');
        const arrowFontFamily = document.getElementById('arrowFontFamily');
        const arrowRotation = document.getElementById('arrowRotation');
        const arrowFillColor = document.getElementById('arrowFillColor'); // Line color for arrow
        const arrowFillTransparency = document.getElementById('arrowFillTransparency');
        const arrowFillTransparencyValue = document.getElementById('arrowFillTransparencyValue');
        const arrowTextColor = document.getElementById('arrowTextColor');
        const arrowTextBackgroundColor = document.getElementById('arrowTextBackgroundColor');
        const arrowLineWidth = document.getElementById('arrowLineWidth');
        const arrowHeadSize = document.getElementById('arrowHeadSize');
        const arrowPaddingX = document.getElementById('arrowPaddingX');
        const arrowPaddingY = document.getElementById('arrowPaddingY');
        const arrowFlipText = document.getElementById('arrowFlipText');
        const deleteArrowBtn = document.getElementById('deleteArrowBtn');
        const cancelArrowBtn = document.getElementById('cancelArrowBtn');
        const applyArrowBtn = document.getElementById('applyArrowBtn');

        // Add new UI elements for the custom confirm modal
        const confirmModal = document.getElementById('confirmModal');
        const confirmMessage = document.getElementById('confirmMessage');
        const confirmOkBtn = document.getElementById('confirmOkBtn');
        const confirmCancelBtn = document.getElementById('confirmCancelBtn');

        let confirmCallback = null;

        /**
         * Custom modal for confirmation dialogs.
         * @param {string} message - The message to display in the confirmation dialog.
         * @param {function(boolean): void} callback - The callback function to execute with the user's choice (true for OK, false for Cancel).
         */
        function showConfirmModal(message, callback) {
            confirmMessage.textContent = message;
            confirmCallback = callback;
            confirmModal.classList.remove('hidden');
        }

        // Event listeners for the custom confirm modal buttons
        confirmOkBtn.addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback(true);
            }
            confirmModal.classList.add('hidden');
        });

        confirmCancelBtn.addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback(false);
            }
            confirmModal.classList.add('hidden');
        });


        /**
         * Converts a hexadecimal color string to RGBA with a given transparency.
         * @param {string} hex - The hexadecimal color string (e.g., "#RRGGBB").
         * @param {number} alpha - The transparency value (0 to 1).
         * @returns {string} The RGBA color string.
         */
        function hexToRgba(hex, alpha) {
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        /**
         * Draws a rounded rectangle.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} x - The x-coordinate of the top-left corner.
         * @param {number} y - The y-coordinate of the top-left corner.
         * @param {number} width - The width of the rectangle.
         * @param {number} height - The height of the rectangle.
         * @param {number} radius - The corner radius.
         */
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        /**
         * Rotates the canvas context around a specific point.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} x - The x-coordinate of the rotation center.
         * @param {number} y - The y-coordinate of the rotation center.
         * @param {number} angle - The rotation angle in radians.
         */
        function rotateContext(ctx, x, y, angle) {
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.translate(-x, -y);
        }

        /**
         * Calculates the distance between two points.
         * @param {number} p1x - x-coordinate of point 1.
         * @param {number} p1y - y-coordinate of point 1.
         * @param {number} p2x - x-coordinate of point 2.
         * @param {number} p2y - y-coordinate of point 2.
         * @returns {number} The distance.
         */
        function dist(p1x, p1y, p2x, p2y) {
            return Math.sqrt(Math.pow(p2x - p1x, 2) + Math.pow(p2y - p1y, 2));
        }

        /**
         * Calculates the angle between a point and the center of a shape, relative to the x-axis.
         * @param {number} cx - Center x of the shape.
         * @param {number} cy - Center y of the shape.
         * @param {number} px - Point x.
         * @param {number} py - Point y.
         * @returns {number} Angle in radians.
         */
        function getAngle(cx, cy, px, py) {
            return Math.atan2(py - cy, px - cx);
        }

        /**
         * Gets mouse coordinates relative to the canvas, accounting for zoom and pan.
         * @param {MouseEvent|TouchEvent} event - The mouse or touch event.
         * @returns {object} {x, y} coordinates.
         */
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // Corrected mouse position calculation: inverse of what's applied in drawCanvas
            const mouseX = (clientX - rect.left - panX) / currentZoom;
            const mouseY = (clientY - rect.top - panY) / currentZoom;
            return { x: mouseX, y: mouseY };
        }

        /**
         * Gets raw mouse coordinates relative to the canvas element, without pan/zoom.
         * @param {MouseEvent|TouchEvent} event - The mouse or touch event.
         * @returns {object} {x, y} coordinates.
         */
        function getRawMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            return { x, y };
        }


        // --- Shape Classes ---

        /**
         * Base class for drawable shapes on the canvas.
         */
        class CanvasShape {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.rotation = 0; // In degrees
            }

            // Abstract methods to be implemented by subclasses
            draw(ctx) {
                throw new Error("draw() must be implemented by subclass");
            }

            contains(mouseX, mouseY) {
                throw new Error("contains() must be implemented by subclass");
            }

            getCenter() {
                return {
                    x: this.x + this.width / 2,
                    y: this.y + this.height / 2
                };
            }

            // Common method to get resize handles
            getHandles() {
                const handleSize = 8;
                
                // Calculate unrotated handle position at bottom-right corner
                const handleX = this.x + this.width;
                const handleY = this.y + this.height;
                
                const handle = {
                    x: handleX,
                    y: handleY,
                    width: handleSize,
                    height: handleSize,
                    size: handleSize,
                    type: 'resize',
                    originalX: handleX,
                    originalY: handleY
                };
                
                return [handle];
            }

            // Common method to get rotation handles
            getRotationHandles() {
                const handleSize = 24; // Increased size
                const halfHandle = handleSize / 2;
                const offset = 30; // Distance from bounding box
                const { x, y, width, height, rotation } = this;
                const center = this.getCenter();

                // Calculate radius for rotation handles from center to corner + offset
                const radius = Math.sqrt((width / 2 + offset) ** 2 + (height / 2 + offset) ** 2);


                const rotationHandles = [];

                for (let i = 0; i < 4; i++) {
                    const angleOffset = Math.PI / 4 + i * Math.PI / 2; // Offset for each handle
                    const actualAngle = (rotation * Math.PI / 180) + angleOffset;

                    const hX = center.x + radius * Math.cos(actualAngle);
                    const hY = center.y + radius * Math.sin(actualAngle);

                    rotationHandles.push({
                        id: `rot${i + 1}`,
                        x: hX - halfHandle,
                        y: hY - halfHandle,
                        width: handleSize,
                        height: handleSize,
                        cursor: 'grab' // Or 'grabbing'
                    });
                }
                return rotationHandles;
            }
        }


        /**
         * Represents a Speech Bubble object for the canvas.
         */
        class SpeechBubble extends CanvasShape {
            constructor(x, y, width, height,
                        text = 'Hello!', fontSize = 24, fontFamily = 'Inter', textColor = '#000000',
                        fillColor = '#ffffff', fillTransparency = 1,
                        borderColor = '#000000', borderTransparency = 1, borderWidth = 2,
                        tailX = x + width / 2, tailY = y + height + 30, // Default tail position
                        tailBaseWidth = 20, paddingX = 15, paddingY = 10, cornerRadius = 15,
                        flipText = false, tailBaseSide = 'bottom', tailBaseAlignment = 'center') {
                super(x, y, width, height);
                this.text = text;
                this.fontSize = fontSize;
                this.fontFamily = fontFamily;
                this.textColor = textColor;
                this.fillColor = fillColor;
                this.fillTransparency = fillTransparency;
                this.borderColor = borderColor;
                this.borderTransparency = borderTransparency;
                this.borderWidth = borderWidth;
                this.tailX = tailX;
                this.tailY = tailY;
                this.tailBaseWidth = tailBaseWidth;
                this.paddingX = paddingX;
                this.paddingY = paddingY;
                this.cornerRadius = cornerRadius;
                this.flipText = flipText;
                this.tailBaseSide = tailBaseSide;
                this.tailBaseAlignment = tailBaseAlignment;

                // Adjust initial tail tip position based on new base side/alignment
                this.updateTailTipPosition();
            }

            /**
             * Calculates the initial tail tip position based on the chosen tailBaseSide and tailBaseAlignment.
             * This function should be called when the tailBaseSide or tailBaseAlignment changes.
             */
            updateTailTipPosition() {
                console.log('Updating tail position for side:', this.tailBaseSide);
                const bodyX = this.x;
                const bodyY = this.y;
                const bodyWidth = this.width;
                const bodyHeight = this.height;
                const tailLength = 30; // Default length of the tail when first created/reset

                let basePointX, basePointY;

                switch (this.tailBaseSide) {
                    case 'bottom':
                        basePointY = bodyY + bodyHeight;
                        if (this.tailBaseAlignment === 'start') {
                            basePointX = bodyX + this.cornerRadius;
                        } else if (this.tailBaseAlignment === 'end') {
                            basePointX = bodyX + bodyWidth - this.cornerRadius;
                        } else { // center
                            basePointX = bodyX + bodyWidth / 2;
                        }
                        this.tailX = basePointX;
                        this.tailY = basePointY + tailLength;
                        console.log('New tail position (bottom):', this.tailX, this.tailY);
                        break;
                    case 'top':
                        basePointY = bodyY;
                        if (this.tailBaseAlignment === 'start') {
                            basePointX = bodyX + this.cornerRadius;
                        } else if (this.tailBaseAlignment === 'end') {
                            basePointX = bodyX + bodyWidth - this.cornerRadius;
                        } else { // center
                            basePointX = bodyX + bodyWidth / 2;
                        }
                        this.tailX = basePointX;
                        this.tailY = basePointY - tailLength;
                        console.log('New tail position (top):', this.tailX, this.tailY);
                        break;
                    case 'left':
                        basePointX = bodyX;
                        if (this.tailBaseAlignment === 'start') {
                            basePointY = bodyY + this.cornerRadius;
                        } else if (this.tailBaseAlignment === 'end') {
                            basePointY = bodyY + bodyHeight - this.cornerRadius;
                        } else { // center
                            basePointY = bodyY + bodyHeight / 2;
                        }
                        this.tailX = basePointX - tailLength;
                        this.tailY = basePointY;
                        console.log('New tail position (left):', this.tailX, this.tailY);
                        break;
                    case 'right':
                        basePointX = bodyX + bodyWidth;
                        if (this.tailBaseAlignment === 'start') {
                            basePointY = bodyY + this.cornerRadius;
                        } else if (this.tailBaseAlignment === 'end') {
                            basePointY = bodyY + bodyHeight - this.cornerRadius;
                        } else { // center
                            basePointY = bodyY + bodyHeight / 2;
                        }
                        this.tailX = basePointX + tailLength;
                        this.tailY = basePointY;
                        console.log('New tail position (right):', this.tailX, this.tailY);
                        break;
                }
            }


            draw(ctx, isSelected = false, isCtrlPressed = false) {
                ctx.save();
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                rotateContext(ctx, centerX, centerY, this.rotation * Math.PI / 180);

                // Draw speech bubble body
                ctx.fillStyle = hexToRgba(this.fillColor, this.fillTransparency);
                ctx.strokeStyle = hexToRgba(this.borderColor, this.borderTransparency);
                ctx.lineWidth = this.borderWidth;

                roundRect(ctx, this.x, this.y, this.width, this.height, this.cornerRadius);
                ctx.fill();
                ctx.stroke();

                // Draw speech bubble tail
                ctx.beginPath();
                let tailBase1X, tailBase1Y, tailBase2X, tailBase2Y;

                // Calculate tail base points dynamically
                switch (this.tailBaseSide) {
                    case 'bottom':
                        tailBase1X = this.x + this.width * (this.tailBaseAlignment === 'start' ? 0.1 : this.tailBaseAlignment === 'end' ? 0.9 : 0.5) - this.tailBaseWidth / 2;
                        tailBase2X = this.x + this.width * (this.tailBaseAlignment === 'start' ? 0.1 : this.tailBaseAlignment === 'end' ? 0.9 : 0.5) + this.tailBaseWidth / 2;
                        tailBase1Y = this.y + this.height;
                        tailBase2Y = this.y + this.height;
                        break;
                    case 'top':
                        tailBase1X = this.x + this.width * (this.tailBaseAlignment === 'start' ? 0.1 : this.tailBaseAlignment === 'end' ? 0.9 : 0.5) - this.tailBaseWidth / 2;
                        tailBase2X = this.x + this.width * (this.tailBaseAlignment === 'start' ? 0.1 : this.tailBaseAlignment === 'end' ? 0.9 : 0.5) + this.tailBaseWidth / 2;
                        tailBase1Y = this.y;
                        tailBase2Y = this.y;
                        break;
                    case 'left':
                        tailBase1Y = this.y + this.height * (this.tailBaseAlignment === 'start' ? 0.1 : this.tailBaseAlignment === 'end' ? 0.9 : 0.5) - this.tailBaseWidth / 2;
                        tailBase2Y = this.y + this.height * (this.tailBaseAlignment === 'start' ? 0.1 : this.tailBaseAlignment === 'end' ? 0.9 : 0.5) + this.tailBaseWidth / 2;
                        tailBase1X = this.x;
                        tailBase2X = this.x;
                        break;
                    case 'right':
                        tailBase1Y = this.y + this.height * (this.tailBaseAlignment === 'start' ? 0.1 : this.tailBaseAlignment === 'end' ? 0.9 : 0.5) - this.tailBaseWidth / 2;
                        tailBase2Y = this.y + this.height * (this.tailBaseAlignment === 'start' ? 0.1 : this.tailBaseAlignment === 'end' ? 0.9 : 0.5) + this.tailBaseWidth / 2;
                        tailBase1X = this.x + this.width;
                        tailBase2X = this.x + this.width;
                        break;
                }

                ctx.moveTo(tailBase1X, tailBase1Y);
                ctx.lineTo(this.tailX, this.tailY); // Tip of the tail
                ctx.lineTo(tailBase2X, tailBase2Y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Draw text inside the bubble
                ctx.fillStyle = this.textColor;
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const textX = this.x + this.width / 2;
                const textY = this.y + this.height / 2;

                if (this.flipText) {
                    rotateContext(ctx, textX, textY, Math.PI); // Rotate text by 180 degrees
                }
                ctx.fillText(this.text, textX, textY);

                if (this.flipText) {
                    rotateContext(ctx, textX, textY, -Math.PI); // Rotate back for other elements
                }

                ctx.restore(); // Restore context after rotation

                // Draw selection border and handles if selected
                if (isSelected) {
                    ctx.save();
                    rotateContext(ctx, centerX, centerY, this.rotation * Math.PI / 180);

                    // Selection bounding box (unrotated for handles)
                    ctx.strokeStyle = '#00f';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                    ctx.setLineDash([]); // Reset line dash

                    // Draw resize handle (single red handle)
                    const handle = this.getHandles()[0];
                    // Draw handle using its original position (since context is already rotated)
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(handle.x, handle.y, handle.width, handle.height);

                    // Draw tail tip handle
                    ctx.beginPath();
                    ctx.arc(this.tailX, this.tailY, 7, 0, Math.PI * 2); // Radius for tail handle hit area
                    ctx.fillStyle = '#f00'; // Red for tail handle
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.restore(); // Restore context after internal rotation

                    // Draw rotation handles if Ctrl is pressed
                    if (isCtrlPressed) {
                        const rotationHandles = this.getRotationHandles();
                        for (const handle of rotationHandles) {
                            const centerX = handle.x + handle.width / 2;
                            const centerY = handle.y + handle.height / 2;
                            const radius = handle.width / 2;
                            
                            // Draw circular arrow handle
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(0, 100, 255, 0.7)'; // Blue transparent background
                            ctx.fill();
                            
                            // Draw arrow head
                            ctx.beginPath();
                            ctx.moveTo(centerX, centerY);
                            //ctx.lineTo(centerX + radius * 0.6, centerY);
                            //ctx.lineTo(centerX + radius * 0.6 - radius * 0.2, centerY + radius * 0.2);
                            //ctx.lineTo(centerX + radius * 0.6, centerY);
                            //ctx.lineTo(centerX + radius * 0.6 - radius * 0.2, centerY - radius * 0.2);
                            ctx.lineTo(centerX + radius * 0.4, centerY);  // Reduced from 0.6
                            ctx.lineTo(centerX + radius * 0.4 - radius * 0.15, centerY + radius * 0.15);  // Reduced from 0.2
                            ctx.lineTo(centerX + radius * 0.4, centerY);
                            ctx.lineTo(centerX + radius * 0.4 - radius * 0.15, centerY - radius * 0.15);
                            ctx.closePath();
                            ctx.fillStyle = 'white';
                            ctx.fill();
                            
                            // Draw circular arc
                            ctx.beginPath();
                            //ctx.arc(centerX, centerY, radius * 0.7, 0, Math.PI * 1.5);
                            ctx.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 1.5); 
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 3;
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                    }

                    // Draw plus symbols if Ctrl is pressed
                    if (isCtrlPressed) {
                        ctx.save();
                        ctx.strokeStyle = '#008000'; // Green
                        ctx.lineWidth = 3; // Increased thickness
                        
                        // Calculate plus symbol positions relative to bubble edges
                        // Position them just inside the bubble, accounting for padding
                        const plusPadding = 1; // Small padding from edge
                        const plusSize = 8; // Size of plus symbol arms
                        
                        // Calculate distances from center
                        const plusWidthDistance = (this.width / 2) - plusSize - plusPadding;
                        const plusHeightDistance = (this.height / 2) - plusSize - plusPadding;
                        
                        // Apply rotation to plus symbols
                        rotateContext(ctx, centerX, centerY, this.rotation * Math.PI / 180);
                        
                        // Draw plus symbols positioned just inside the bubble
                        // Top plus symbol (rotated)
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - plusHeightDistance);
                        ctx.lineTo(centerX, centerY - plusHeightDistance + plusSize);
                        ctx.moveTo(centerX - plusSize/2, centerY - plusHeightDistance + plusSize/2);
                        ctx.lineTo(centerX + plusSize/2, centerY - plusHeightDistance + plusSize/2);
                        ctx.stroke();
                        
                        // Right plus symbol (rotated)
                        ctx.beginPath();
                        ctx.moveTo(centerX + plusWidthDistance, centerY);
                        ctx.lineTo(centerX + plusWidthDistance - plusSize, centerY);
                        ctx.moveTo(centerX + plusWidthDistance - plusSize/2, centerY - plusSize/2);
                        ctx.lineTo(centerX + plusWidthDistance - plusSize/2, centerY + plusSize/2);
                        ctx.stroke();
                        
                        // Bottom plus symbol (rotated)
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY + plusHeightDistance);
                        ctx.lineTo(centerX, centerY + plusHeightDistance - plusSize);
                        ctx.moveTo(centerX - plusSize/2, centerY + plusHeightDistance - plusSize/2);
                        ctx.lineTo(centerX + plusSize/2, centerY + plusHeightDistance - plusSize/2);
                        ctx.stroke();
                        
                        // Left plus symbol (rotated)
                        ctx.beginPath();
                        ctx.moveTo(centerX - plusWidthDistance, centerY);
                        ctx.lineTo(centerX - plusWidthDistance + plusSize, centerY);
                        ctx.moveTo(centerX - plusWidthDistance + plusSize/2, centerY - plusSize/2);
                        ctx.lineTo(centerX - plusWidthDistance + plusSize/2, centerY + plusSize/2);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                }
            }


            /**
             * Checks if a point is inside the speech bubble. This is approximate for rotation.
             * For accurate hit testing on rotated shapes, more complex geometry is needed (e.g., transforming mouse coordinates).
             * For simplicity, this checks against the (unrotated) bounding box.
             * @param {number} mouseX - Mouse X coordinate.
             * @param {number} mouseY - Mouse Y coordinate.
             * @returns {boolean} True if the point is inside, false otherwise.
             */
            contains(mouseX, mouseY) {
                // To accurately check for containment when rotated, we need to
                // transform the mouse coordinates back to the shape's local, unrotated coordinate system.
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // Translate mouse to origin relative to shape center
                let translatedX = mouseX - centerX;
                let translatedY = mouseY - centerY;

                // Rotate mouse coordinates by negative of shape's rotation
                const angleRad = -this.rotation * Math.PI / 180;
                const rotatedX = translatedX * Math.cos(angleRad) - translatedY * Math.sin(angleRad);
                const rotatedY = translatedX * Math.sin(angleRad) + translatedY * Math.cos(angleRad);

                // Check if the rotated point is within the unrotated bounding box
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;

                const inRect = rotatedX >= -halfWidth && rotatedX <= halfWidth &&
                               rotatedY >= -halfHeight && rotatedY <= halfHeight;

                // Also check if it's near the tail tip
                const tailHandleRadius = 10; // Increased hit area for tail
                const tailDist = dist(mouseX, mouseY, this.tailX, this.tailY);
                const nearTail = tailDist < tailHandleRadius;

                return inRect || nearTail;
            }

            /**
             * Checks if a point is within a resize handle.
             * @param {number} mouseX - Mouse X coordinate.
             * @param {number} mouseY - Mouse Y coordinate.
             * @returns {string|null} The handle name ('tl', 'tr', etc.) or null if not on a handle.
             */
             onResizeHandle(mouseX, mouseY) {
                const handle = this.getHandles()[0];
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Transform mouse coordinates to shape's coordinate system
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const angleRad = -this.rotation * Math.PI / 180;
                const transformedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                const transformedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                
                // Transform handle position to shape's coordinate system
                const handleX = handle.x - centerX;
                const handleY = handle.y - centerY;
                
                // Calculate distance in shape's coordinate system
                const distToHandle = Math.sqrt(
                    (transformedX - handleX) ** 2 + 
                    (transformedY - handleY) ** 2
                );
                
                const hitRadius = 15;
                if (distToHandle <= hitRadius) {
                    return 'resize';
                }
                return null;
            }

            onTailHandle(mouseX, mouseY) {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Transform mouse coordinates to shape's coordinate system
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const angleRad = -this.rotation * Math.PI / 180;
                const transformedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                const transformedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                
                // Transform tail position to shape's coordinate system
                const tailDX = this.tailX - centerX;
                const tailDY = this.tailY - centerY;
                
                // Calculate distance in shape's coordinate system
                const distToTail = Math.sqrt(
                    (transformedX - tailDX) ** 2 + 
                    (transformedY - tailDY) ** 2
                );
                
                const tailHandleRadius = 10;
                if (distToTail < tailHandleRadius) {
                    return true;
                }
                return false;
            }

            onRotationHandle(mouseX, mouseY) {
                const rotationHandles = this.getRotationHandles();
                const rotationHandleHitBuffer = 20;
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Transform mouse coordinates to shape's coordinate system
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const angleRad = -this.rotation * Math.PI / 180;
                const transformedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                const transformedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                
                for (const handle of rotationHandles) {
                    // Transform handle position to shape's coordinate system
                    const handleX = handle.x + handle.width / 2 - centerX;
                    const handleY = handle.y + handle.height / 2 - centerY;
                    const rotatedHandleX = handleX * Math.cos(angleRad) - handleY * Math.sin(angleRad);
                    const rotatedHandleY = handleX * Math.sin(angleRad) + handleY * Math.cos(angleRad);
                    
                    const distToHandle = Math.sqrt(
                        (transformedX - rotatedHandleX) ** 2 + 
                        (transformedY - rotatedHandleY) ** 2
                    );
                    
                    if (distToHandle < (handle.width / 2) + rotationHandleHitBuffer) {
                        return handle.id;
                    }
                }
                return null;
            }

            updateFromEditor(properties) {
                // Set text properties
                this.text = properties.text;
                this.fontSize = properties.fontSize !== undefined ? parseFloat(properties.fontSize) : this.fontSize;
                this.fontFamily = properties.fontFamily || this.fontFamily;
                this.textColor = properties.textColor || this.textColor;
                
                // Set fill properties
                this.fillColor = properties.fillColor || this.fillColor;
                this.fillTransparency = properties.fillTransparency !== undefined ? parseFloat(properties.fillTransparency) : this.fillTransparency;
                
                // Set border properties
                this.borderColor = properties.borderColor || this.borderColor;
                this.borderTransparency = properties.borderTransparency !== undefined ? parseFloat(properties.borderTransparency) : this.borderTransparency;
                this.borderWidth = properties.borderWidth !== undefined ? parseFloat(properties.borderWidth) : this.borderWidth;
                
                // Set tail properties
                this.tailBaseSide = properties.tailBaseSide || this.tailBaseSide;
                this.tailBaseAlignment = properties.tailBaseAlignment || this.tailBaseAlignment;
                
                // Set padding and radius
                this.paddingX = properties.paddingX !== undefined ? parseFloat(properties.paddingX) : this.paddingX;
                this.paddingY = properties.paddingY !== undefined ? parseFloat(properties.paddingY) : this.paddingY;
                this.cornerRadius = properties.cornerRadius !== undefined ? parseFloat(properties.cornerRadius) : this.cornerRadius;
                
                // Set flip text
                this.flipText = properties.flipText !== undefined ? properties.flipText : this.flipText;
                
                // Update tail position based on new properties
                this.updateTailTipPosition();
            }

            /**
             * Checks if a point is within any of the plus symbols.
             * @param {number} mouseX - Mouse X coordinate.
             * @param {number} mouseY - Mouse Y coordinate.
             * @returns {string|null} The side ('top', 'right', 'bottom', 'left') or null if not on a plus symbol.
             */
            onPlusSymbol(mouseX, mouseY) {
                const plusPadding = 1;
                const plusSize = 15;
                const plusHitBuffer = 5; // Increased hit area
                
                // Calculate distances from center
                const plusWidthDistance = (this.width / 2) - plusSize - plusPadding;
                const plusHeightDistance = (this.height / 2) - plusSize - plusPadding;
                
                // Calculate plus symbol positions relative to center
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Transform mouse coordinates to bubble's local coordinate system
                // Translate to center
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                
                // Rotate by negative of bubble's rotation
                const angleRad = -this.rotation * Math.PI / 180;
                const rotatedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                const rotatedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                
                // Define plus symbol positions in local coordinates
                const plusPositions = [
                    { side: 'top', x: 0, y: -plusHeightDistance },
                    { side: 'right', x: plusWidthDistance, y: 0 },
                    { side: 'bottom', x: 0, y: plusHeightDistance },
                    { side: 'left', x: -plusWidthDistance, y: 0 }
                ];
                
                // Check each plus symbol in local coordinates
                for (const pos of plusPositions) {
                    // Check vertical plus arm
                    if (Math.abs(rotatedX - pos.x) < plusSize/2 + plusHitBuffer) {
                        if (Math.abs(rotatedY - pos.y) < plusSize + plusHitBuffer) {
                            console.log('Hit detected on:', pos.side);
                            return pos.side;
                        }
                    }
                    
                    // Check horizontal plus arm
                    if (Math.abs(rotatedY - pos.y) < plusSize/2 + plusHitBuffer) {
                        if (Math.abs(rotatedX - pos.x) < plusSize + plusHitBuffer) {
                            console.log('Hit detected on:', pos.side);
                            return pos.side;
                        }
                    }
                }
                
                return null;
            }
                
        }


        /**
         * Represents an Arrow object for the canvas.
         */
        class Arrow extends CanvasShape {
            constructor(x1, y1, x2, y2,
                        text = 'Label', fontSize = 20, fontFamily = 'Inter', textColor = '#ffffff', textBackgroundColor = '#000000',
                        fillColor = '#000000', fillTransparency = 1, lineWidth = 3, headSize = 15,
                        paddingX = 10, paddingY = 5, flipText = false) {
                // Arrow coordinates x1, y1, x2, y2 define the line
                // We'll calculate width/height from these for the bounding box.
                // For simplicity, x/y can be min(x1,x2), min(y1,y2) and width/height max(x)-min(x), max(y)-min(y)
                super(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.text = text;
                this.fontSize = fontSize;
                this.fontFamily = fontFamily;
                this.textColor = textColor;
                this.textBackgroundColor = textBackgroundColor;
                this.fillColor = fillColor;
                this.fillTransparency = fillTransparency;
                this.lineWidth = lineWidth;
                this.headSize = headSize;
                this.paddingX = paddingX;
                this.paddingY = paddingY;
                this.flipText = flipText;
            }

            // Recalculate bounding box based on x1, y1, x2, y2
            updateBoundingBox() {
                this.x = Math.min(this.x1, this.x2);
                this.y = Math.min(this.y1, this.y2);
                this.width = Math.abs(this.x2 - this.x1);
                this.height = Math.abs(this.y2 - this.y1);
            }

            // Track which handle is being dragged
            startDragHandle = null;
            endDragHandle = null;

            // Reset drag handles
            resetDragHandles() {
                this.startDragHandle = null;
                this.endDragHandle = null;
            }

            draw(ctx, isSelected = false, isCtrlPressed = false) {
                ctx.save();
                // For arrow, rotation is usually implicit in x1, y1, x2, y2.
                // If we want to rotate an arrow, we would rotate the start/end points.
                // However, the `rotation` property is for the entire object's conceptual rotation around its center,
                // which affects where handles and hit-testing occur.

                const arrowAngle = Math.atan2(this.y2 - this.y1, this.x2 - this.x1);
                const lineLength = dist(this.x1, this.y1, this.x2, this.y2);

                ctx.strokeStyle = hexToRgba(this.fillColor, this.fillTransparency);
                ctx.lineWidth = this.lineWidth;

                // Draw arrow line
                ctx.beginPath();
                ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2);
                ctx.stroke();

                // Draw arrow head at (x2, y2)
                ctx.beginPath();
                ctx.moveTo(this.x2, this.y2);
                ctx.lineTo(
                    this.x2 - this.headSize * Math.cos(arrowAngle - Math.PI / 6),
                    this.y2 - this.headSize * Math.sin(arrowAngle - Math.PI / 6)
                );
                ctx.moveTo(this.x2, this.y2);
                ctx.lineTo(
                    this.x2 - this.headSize * Math.cos(arrowAngle + Math.PI / 6),
                    this.y2 - this.headSize * Math.sin(arrowAngle + Math.PI / 6)
                );
                ctx.stroke();

                // Draw text label at the center of the arrow
                const textX = (this.x1 + this.x2) / 2;
                const textY = (this.y1 + this.y2) / 2;

                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Save context before transforming for text
                ctx.save();
                ctx.translate(textX, textY);
                // Calculate the angle to make text always right-side up
                let textAngle = arrowAngle;
                
                // If the arrow is pointing left (angle between 90 and 270 degrees), flip the text
                if (arrowAngle > Math.PI/2 && arrowAngle < 3*Math.PI/2) {
                    textAngle = arrowAngle - Math.PI;
                }
                
                ctx.rotate(textAngle); // Rotate to be parallel to the arrow line
                if (this.flipText) {
                    ctx.rotate(Math.PI); // Additional flip if requested
                }

                // Measure text to draw background in the rotated context
                const textMetrics = ctx.measureText(this.text);
                const textWidth = textMetrics.width;
                const textHeight = this.fontSize * 1.2; // Approximate text height with line height

                // Calculate background dimensions with padding
                const bgPaddingX = this.paddingX * 1.5; // Increased padding
                const bgPaddingY = this.paddingY * 1.5;
                const bgWidth = textWidth + 2 * bgPaddingX;
                const bgHeight = textHeight + 2 * bgPaddingY;
                
                // Position background centered at (0,0) in rotated context
                const bgX = -bgWidth / 2;
                const bgY = -bgHeight / 2;
                
                // Draw rounded background
                ctx.fillStyle = this.textBackgroundColor;
                const bgRadius = bgHeight / 2; // Make corners more rounded
                roundRect(ctx, bgX, bgY, bgWidth, bgHeight, bgRadius);
                
                // Add subtle shadow to background
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.fill();
                ctx.shadowColor = 'transparent'; // Reset shadow

                // Draw text at (0,0) in rotated context
                ctx.fillStyle = this.textColor;
                ctx.fillText(this.text, 0, 0); // Text is now drawn at the rotated origin

                ctx.restore(); // Restore context after text transformation

                ctx.restore(); // Restore context after main arrow transformation

                // Draw selection border and handles if selected
                if (isSelected) {
                    ctx.save();
                    // Draw handles at x1, y1 and x2, y2
                    const handleSize = 12; // Increased size
                    const halfHandle = handleSize / 2;

                    ctx.fillStyle = '#00f'; // Blue handles
                    ctx.fillRect(this.x1 - halfHandle, this.y1 - halfHandle, handleSize, handleSize);
                    ctx.fillRect(this.x2 - halfHandle, this.y2 - halfHandle, handleSize, handleSize);

                    // Draw selection box around the entire arrow's bounding box
                    // Calculate bounding box considering text label (using current unrotated bounding box for simplicity)
                    const minX = Math.min(this.x1, this.x2, this.x);
                    const minY = Math.min(this.y1, this.y2, this.y);
                    const maxX = Math.max(this.x1, this.x2, this.x + this.width);
                    const maxY = Math.max(this.y1, this.y2, this.y + this.height);


                    ctx.strokeStyle = '#00f';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                    ctx.setLineDash([]); // Reset line dash

                    ctx.restore();

                    // Draw rotation handles if Ctrl is pressed
                    if (isCtrlPressed) {
                        const rotationHandles = this.getRotationHandles();
                        for (const handle of rotationHandles) {
                            ctx.beginPath();
                            ctx.arc(handle.x + handle.width / 2, handle.y + handle.height / 2, handle.width / 2, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(0, 100, 255, 0.7)'; // Blue transparent
                            ctx.fill();
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                }
            }

            /**
             * Checks if a point is within the arrow's interactive area (line or text background).
             * @param {number} mouseX - Mouse X coordinate.
             * @param {number} mouseY - Mouse Y coordinate.
             * @returns {boolean} True if the point is inside, false otherwise.
             */
            contains(mouseX, mouseY) {
                // Check if inside the text background (simpler, more robust for picking)
                ctx.font = `${this.fontSize}px ${this.fontFamily}`; // Needed for measureText
                const textMetrics = ctx.measureText(this.text);
                const textWidth = textMetrics.width;
                const textHeight = this.fontSize;

                const textX = (this.x1 + this.x2) / 2;
                const textY = (this.y1 + this.y2) / 2;

                // For rotated text background hit detection, draw a temporary rotated rect path
                ctx.save();
                ctx.translate(textX, textY);
                ctx.rotate(Math.atan2(this.y2 - this.y1, this.x2 - this.x1)); // Rotate to arrow angle
                if (this.flipText) {
                    ctx.rotate(Math.PI);
                }
                
                // Calculate background dimensions with padding
                const bgPaddingX = this.paddingX * 1.5;
                const bgPaddingY = this.paddingY * 1.5;
                const bgWidth = textWidth + 2 * bgPaddingX;
                const bgHeight = textHeight + 2 * bgPaddingY;
                
                // Position background centered at (0,0) in rotated context
                const bgX = -bgWidth / 2;
                const bgY = -bgHeight / 2;
                
                ctx.beginPath();
                roundRect(ctx, bgX, bgY, bgWidth, bgHeight, bgHeight/2);
                const inTextBg = ctx.isPointInPath(mouseX, mouseY);
                ctx.restore(); // Restore context

                if (inTextBg) {
                    return true;
                }

                // Check if near the line itself (allowing for a small buffer)
                const buffer = 8; // Pixels buffer around the line - increased hot area
                const lineLength = dist(this.x1, this.y1, this.x2, this.y2);
                if (lineLength === 0) return false; // Avoid division by zero

                const dot = ((mouseX - this.x1) * (this.x2 - this.x1) + (mouseY - this.y1) * (this.y2 - this.y1)) / (lineLength * lineLength);
                const closestX = this.x1 + dot * (this.x2 - this.x1);
                const closestY = this.y1 + dot * (this.y2 - this.y1);

                const distToLine = dist(mouseX, mouseY, closestX, closestY);

                // Check if the closest point is on the segment and distance is within buffer
                if (distToLine < buffer && dot >= -0.1 && dot <= 1.1) { // Slightly extend segment for hit detection
                    return true;
                }
                return false;
            }

            /**
             * Checks if a point is within a resize handle (start or end of the arrow).
             * @param {number} mouseX - Mouse X coordinate.
             * @param {number} mouseY - Mouse Y coordinate.
             * @returns {string|null} 'start' or 'end' or null.
             */
            onResizeHandle(mouseX, mouseY) {
                const hitRadius = 15;
                const dx1 = mouseX - this.x1;
                const dy1 = mouseY - this.y1;
                const dx2 = mouseX - this.x2;
                const dy2 = mouseY - this.y2;
                
                if (dx1 * dx1 + dy1 * dy1 <= hitRadius * hitRadius) {
                    this.startDragHandle = true;
                    return 'start';
                }
                if (dx2 * dx2 + dy2 * dy2 <= hitRadius * hitRadius) {
                    this.endDragHandle = true;
                    return 'end';
                }
                return null;
            }

            updateFromEditor(properties) {
                this.text = properties.text;
                this.fontSize = parseFloat(properties.fontSize);
                this.fontFamily = properties.fontFamily;
                this.textColor = properties.textColor;
                this.textBackgroundColor = properties.textBackgroundColor;
                this.fillColor = properties.fillColor; // This is line color for arrow
                this.fillTransparency = parseFloat(properties.fillTransparency);
                this.lineWidth = parseFloat(properties.lineWidth);
                this.headSize = parseFloat(properties.headSize);
                this.paddingX = parseFloat(properties.paddingX);
                this.paddingY = parseFloat(properties.paddingY);

                // Apply rotation by adjusting x1,y1,x2,y2 points around their center
                this.applyRotationToPoints(parseFloat(properties.rotation));
                this.flipText = properties.flipText;
            }

            // This function applies the rotation to the arrow's start and end points
            applyRotationToPoints(newRotationDegrees) {
                const oldRotationRadians = this.rotation * Math.PI / 180;
                const newRotationRadians = newRotationDegrees * Math.PI / 180;
                const deltaRotation = newRotationRadians - oldRotationRadians;

                if (deltaRotation === 0) return; // No change needed

                const centerX = (this.x1 + this.x2) / 2;
                const centerY = (this.y1 + this.y2) / 2;

                // Rotate point 1
                let tempX1 = this.x1 - centerX;
                let tempY1 = this.y1 - centerY;
                this.x1 = tempX1 * Math.cos(deltaRotation) - tempY1 * Math.sin(deltaRotation) + centerX;
                this.y1 = tempX1 * Math.sin(deltaRotation) + tempY1 * Math.cos(deltaRotation) + centerY;

                // Rotate point 2
                let tempX2 = this.x2 - centerX;
                let tempY2 = this.y2 - centerY;
                this.x2 = tempX2 * Math.cos(deltaRotation) - tempY2 * Math.sin(deltaRotation) + centerX;
                this.y2 = tempX2 * Math.sin(deltaRotation) + tempY2 * Math.cos(deltaRotation) + centerY;

                this.rotation = newRotationDegrees; // Update stored rotation
                this.updateBoundingBox(); // Update bounding box after point change
            }

             /**
             * Gets resize handles for the arrow (one at each end).
             * @returns {Array} Array of handle objects.
             */
            getHandles() {
                const handleSize = 8;
                
                // Calculate handle positions at both ends
                const handle1 = {
                    x: this.x1,
                    y: this.y1,
                    width: handleSize,
                    height: handleSize,
                    size: handleSize,
                    type: 'resize',
                    originalX: this.x1,
                    originalY: this.y1
                };

                const handle2 = {
                    x: this.x2,
                    y: this.y2,
                    width: handleSize,
                    height: handleSize,
                    size: handleSize,
                    type: 'resize',
                    originalX: this.x2,
                    originalY: this.y2
                };
                
                return [handle1, handle2];
            }

            getCenter() {
                // For an arrow, the center is the midpoint of its line.
                return {
                    x: (this.x1 + this.x2) / 2,
                    y: (this.y1 + this.y2) / 2
                };
            }

            // Arrow specific rotation handles (based on its true geometric center)
            onRotationHandle(mouseX, mouseY) {
                const rotationHandles = this.getRotationHandles();
                const rotationHandleHitBuffer = 10; // Increased hit area for rotation handles
                for (const handle of rotationHandles) {
                    const distToHandle = dist(mouseX, mouseY, handle.x + handle.width / 2, handle.y + handle.height / 2);
                    if (distToHandle < (handle.width / 2) + rotationHandleHitBuffer) {
                        return handle.id;
                    }
                }
                return null;
            }
        }


        // --- Pointer Animation Functions ---
        let bubblePointerTimeout;
        let arrowPointerTimeout;

        // Show pointer animation
        function showPointer(buttonId, text) {
            const button = document.getElementById(buttonId);
            if (!button) return;

            // Create a temporary pointer element
            const pointer = document.createElement('div');
            pointer.className = 'pointer-overlay absolute';
            pointer.style.display = 'block';
            
            // Position it relative to the button
            const rect = button.getBoundingClientRect();
            pointer.style.left = `${rect.left + window.scrollX}px`;
            pointer.style.top = `${rect.top + window.scrollY}px`;
            
            // Add pointer and text elements
            const pointerDiv = document.createElement('div');
            pointerDiv.className = 'pointer-pointer';
            pointerDiv.style.animation = 'bounce 1s infinite';
            pointer.appendChild(pointerDiv);
            
            const textDiv = document.createElement('div');
            textDiv.className = 'pointer-text';
            textDiv.textContent = text;
            pointer.appendChild(textDiv);
            
            // Add to body
            document.body.appendChild(pointer);
            
            // Remove after 2 seconds
            setTimeout(() => {
                pointer.remove();
            }, 2000);
        }

        // Hide pointer when clicking on canvas
        canvas.addEventListener('click', () => {
            const bubblePointer = document.getElementById('bubblePointer');
            const arrowPointer = document.getElementById('arrowPointer');
            bubblePointer.classList.add('hidden');
            arrowPointer.classList.add('hidden');
            clearTimeout(bubblePointerTimeout);
            clearTimeout(arrowPointerTimeout);
        });

        // --- Canvas Drawing and Management ---

        /**
         * Draws a checkered background pattern on the canvas.
         * This should be called WITHOUT any transformations (translate/scale) on the context.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} cellSize - The size of each square in the checkered pattern.
         * @param {string} color1 - The color of the first set of squares.
         * @param {string} color2 - The color of the second set of squares.
         */
        function drawCheckeredBackground(ctx, cellSize, color1, color2) {
            const numCols = Math.ceil(canvas.width / cellSize);
            const numRows = Math.ceil(canvas.height / cellSize);

            for (let r = 0; r < numRows; r++) {
                for (let c = 0; c < numCols; c++) {
                    // Alternate colors based on row and column parity
                    if ((r + c) % 2 === 0) {
                        ctx.fillStyle = color1;
                    } else {
                        ctx.fillStyle = color2;
                    }
                    ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
                }
            }
        }

        /**
         * Draws all elements on the canvas (image, shapes).
         */
        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear entire canvas

            // Draw checkered background first (no transformations applied yet)
            drawCheckeredBackground(ctx, 20, '#e0e0e0', '#cccccc'); // Light gray and medium gray

            ctx.save(); // Save the state before applying pan and zoom for image/shapes
            ctx.translate(panX, panY);
            ctx.scale(currentZoom, currentZoom);

            // Draw uploaded image
            if (uploadedImage) {
                // Draw the image using its original dimensions, as the context is already scaled by currentZoom
                ctx.drawImage(uploadedImage, 0, 0, uploadedImage.width, uploadedImage.height);
            }

            // Draw all shapes
            shapes.forEach(shape => {
                shape.draw(ctx, shape === selectedShape, isCtrlPressed);
            });
            ctx.restore(); // Restore the state (removes pan and zoom for subsequent drawings outside this function)
        }

        /**
         * Resizes the canvas to fill its container.
         */
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            drawCanvas();
        }

        // Initial resize and draw
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);


        // --- Mouse/Touch Event Handlers ---

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp); // End drag/resize if mouse leaves canvas

        // Touch event listeners
        canvas.addEventListener('touchstart', handleMouseDown);
        canvas.addEventListener('touchmove', handleMouseMove);
        canvas.addEventListener('touchend', handleMouseUp);

        // Add Ctrl-click handler for plus symbols
        canvas.addEventListener('click', (e) => {
            if (e.ctrlKey && selectedShape instanceof SpeechBubble) {
                const { x, y } = getMousePos(e);
                console.log('Mouse click at:', x, y);
                const side = selectedShape.onPlusSymbol(x, y);
                if (side) {
                    console.log('Clicked on plus symbol:', side);
                    // Update tail base side and position
                    selectedShape.tailBaseSide = side;
                    console.log('Setting tailBaseSide to:', side);
                    selectedShape.updateTailTipPosition(); // Recalculate tail tip position
                    console.log('Tail position updated');
                    drawCanvas(); // Redraw to show changes
                } else {
                    console.log('No plus symbol clicked');
                }
            }
        });


        /**
         * Handles mouse down (or touch start) events on the canvas.
         * @param {MouseEvent|TouchEvent} event - The event object.
         */
        function handleMouseDown(event) {
            event.preventDefault(); // Prevent default browser actions like scrolling/text selection
            const { x, y } = getMousePos(event);
            startX = x;
            startY = y;
            // Safely get clientX/Y for panning tracking, considering mouse and touch events
            lastMouseX = (event.touches && event.touches.length > 0) ? event.touches[0].clientX : event.clientX;
            lastMouseY = (event.touches && event.touches.length > 0) ? event.touches[0].clientY : event.clientY;

            console.log('2. Mouse down on canvas at:', x, y);
            console.log('   Current drawingMode:', drawingMode);

            // Check if drawing new shape
            if (drawingMode) {
                console.log('3. Entering drawing mode logic.');
                if (drawingMode === 'bubble') {
                    console.log('   Creating new SpeechBubble.');
                    // Create a bubble with initial size and default tail positions
                    selectedShape = new SpeechBubble(x, y, 100, 60); // Default size
                    // Initial tail tip position will be set by constructor's updateTailTipPosition
                    shapes.push(selectedShape);
                } else if (drawingMode === 'arrow') {
                    console.log('   Creating new Arrow.');
                    selectedShape = new Arrow(x, y, x + 100, y + 0); // Default horizontal arrow
                    shapes.push(selectedShape);
                }
                isResizing = true; // Use resizing flag for initial draw
                resizeHandle = 'br'; // Treat as bottom-right resize for bubbles, 'end' for arrows
                drawCanvas(); // Redraw immediately to show the initial shape outline
                return;
            }

            // Check for existing shape interaction (handles or dragging)
            let foundInteraction = false;
            // Iterate shapes in reverse order to check top-most first
            for (let i = shapes.length - 1; i >= 0; i--) {
                const shape = shapes[i];

                if (selectedShape === shape && isCtrlPressed) {
                    // Check rotation handles first if Ctrl is pressed and shape is selected
                    rotationHandle = shape.onRotationHandle(x, y);
                    if (rotationHandle) {
                        isRotating = true;
                        foundInteraction = true;
                        break;
                    }
                }

                if (selectedShape === shape && shape instanceof SpeechBubble && shape.onTailHandle(x, y)) {
                    isTailMoving = true;
                    foundInteraction = true;
                    break;
                }

                if (selectedShape === shape && shape.onResizeHandle(x, y) === 'resize') {
    isResizing = true;
    resizeHandle = 'resize'; // Simplified since we only have one handle
    foundInteraction = true;
    break;
}

                if (shape.contains(x, y)) {
                    selectedShape = shape;
                    isDragging = true;
                    foundInteraction = true;
                    break;
                }
            }

            if (!foundInteraction) {
                // If no shape was clicked, deselect and start panning (if zoomed in)
                selectedShape = null;
                // Only allow panning if the image is larger than the canvas at the current zoom,
                // or if no image is loaded (then allow free panning of shapes)
                const imageRenderedWidth = uploadedImage ? uploadedImage.width * currentZoom : 0;
                const imageRenderedHeight = uploadedImage ? uploadedImage.height * currentZoom : 0;

                const canPanX = imageRenderedWidth > canvas.width;
                const canPanY = imageRenderedHeight > canvas.height;

                if (canPanX || canPanY || !uploadedImage) {
                    isDragging = true; // Use isDragging for panning the canvas
                } else {
                    isDragging = false; // Prevent dragging background if image fits entirely
                }
            }
            drawCanvas(); // Redraw to show selected state or new shape outline
        }


        /**
         * Handles mouse move (or touch move) events on the canvas.
         * @param {MouseEvent|TouchEvent} event - The event object.
         */
        function handleMouseMove(event) {
            event.preventDefault();
            const { x, y } = getMousePos(event); // x, y are world coordinates
            // Safely get clientX/Y for panning tracking, considering mouse and touch events
            const clientX = (event.touches && event.touches.length > 0) ? event.touches[0].clientX : event.clientX;
            const clientY = (event.touches && event.touches.length > 0) ? event.touches[0].clientY : event.clientY;

            // Update mouse cursor
            updateCursor(x, y);

            // Panning the canvas
            if (!selectedShape && isDragging) {
                const dx = (clientX - lastMouseX);
                const dy = (clientY - lastMouseY);

                panX += dx;
                panY += dy;

                // Implement pan boundaries
                if (uploadedImage) {
                    const imgW = uploadedImage.width * currentZoom;
                    const imgH = uploadedImage.height * currentZoom;

                    // Calculate bounds for panX
                    const minPanX = canvas.width - imgW;
                    const maxPanX = 0;
                    if (imgW < canvas.width) { // If image is smaller than canvas, center it and lock pan
                        panX = (canvas.width - imgW) / 2;
                    } else { // If image is larger, restrict pan
                        panX = Math.max(panX, minPanX);
                        panX = Math.min(panX, maxPanX);
                    }

                    // Calculate bounds for panY
                    const minPanY = canvas.height - imgH;
                    const maxPanY = 0;
                    if (imgH < canvas.height) { // If image is smaller than canvas, center it and lock pan
                        panY = (canvas.height - imgH) / 2;
                    } else { // If image is larger, restrict pan
                        panY = Math.max(panY, minPanY);
                        panY = Math.min(panY, maxPanY);
                    }
                } else {
                    // If no image is loaded, allow panning shapes freely
                    // You might want to add boundaries here too, or let it be "infinite"
                    // For now, let it be effectively infinite when no image.
                }

                lastMouseX = clientX;
                lastMouseY = clientY;
                drawCanvas();
                return;
            }


            if (!selectedShape) return; // No shape selected or being drawn

            // Handle drawing new shape (resizing from startX, startY to current x, y)
            if (drawingMode && isResizing) {
                console.log('4. Moving in drawing mode. Resizing shape.');
                if (drawingMode === 'bubble') {
                    selectedShape.x = Math.min(startX, x);
                    selectedShape.y = Math.min(startY, y);
                    selectedShape.width = Math.abs(x - startX);
                    selectedShape.height = Math.abs(y - startY);
                    selectedShape.updateTailTipPosition(); // Recalculate default tip based on new size/pos
                } else if (drawingMode === 'arrow') {
                    selectedShape.x2 = x;
                    selectedShape.y2 = y;
                    selectedShape.updateBoundingBox(); // Update internal bounding box for selection/handles
                }
                drawCanvas();
                return;
            }

            // Handle dragging existing shape
            if (isDragging && selectedShape) {
                        // For Arrow, handle individual handle dragging with relative position locking
                if (selectedShape instanceof Arrow) {
                    // Check which handle was clicked
                    const handle = selectedShape.onResizeHandle(x, y);
                    
                    if (handle === 'start') {
                        // Move start handle while maintaining relative position to end
                        const dx = x - selectedShape.x1;
                        const dy = y - selectedShape.y1;
                        selectedShape.x1 = x;
                        selectedShape.y1 = y;
                        // Update shape position based on new start point
                        selectedShape.x = (selectedShape.x2 + selectedShape.x1) / 2;
                        selectedShape.y = (selectedShape.y2 + selectedShape.y1) / 2;
                        selectedShape.updateBoundingBox();
                    } else if (handle === 'end') {
                        // Move end handle while maintaining relative position to start
                        const dx = x - selectedShape.x2;
                        const dy = y - selectedShape.y2;
                        selectedShape.x2 = x;
                        selectedShape.y2 = y;
                        // Update shape position based on new end point
                        selectedShape.x = (selectedShape.x2 + selectedShape.x1) / 2;
                        selectedShape.y = (selectedShape.y2 + selectedShape.y1) / 2;
                        selectedShape.updateBoundingBox();
                    } else {
                        // If not on a handle, move the entire shape
                        const dx = x - startX;
                        const dy = y - startY;
                        selectedShape.x += dx;
                        selectedShape.y += dy;
                        selectedShape.x1 += dx;
                        selectedShape.y1 += dy;
                        selectedShape.x2 += dx;
                        selectedShape.y2 += dy;
                        selectedShape.updateBoundingBox();
                    }
                } else {
                    // For other shapes, move the entire shape
                    const dx = x - startX;
                    const dy = y - startY;
                    selectedShape.x += dx;
                    selectedShape.y += dy;
                    if (selectedShape instanceof SpeechBubble) {
                        selectedShape.tailX += dx;
                        selectedShape.tailY += dy;
                    }
                }
                startX = x; // Update start for next move
                startY = y;
                drawCanvas();
                return;
            }

            // Handle resizing
            if (isResizing && selectedShape) {
                const dx = x - startX;
                const dy = y - startY;
                const currentShape = selectedShape;
                const minSize = 20; // Minimum size for shapes

                const centerX = currentShape.x + currentShape.width / 2;
                const centerY = currentShape.y + currentShape.height / 2;
                const angleRad = currentShape.rotation * Math.PI / 180;

                // Rotate mouse change back to local shape coordinates
                const rotatedDx = dx * Math.cos(-angleRad) - dy * Math.sin(-angleRad);
                const rotatedDy = dx * Math.sin(-angleRad) + dy * Math.cos(-angleRad);

                let newX = currentShape.x;
                let newY = currentShape.y;
                let newWidth = currentShape.width;
                let newHeight = currentShape.height;

                if (currentShape instanceof SpeechBubble) {
                    // For our single handle in bottom-right corner:
                    // We'll resize from top-left corner
                    newWidth = Math.max(minSize, currentShape.width + rotatedDx);
                    newHeight = Math.max(minSize, currentShape.height + rotatedDy);
                    
                    // Update tail position relative to new size
                    const scaleWidth = newWidth / currentShape.width;
                    const scaleHeight = newHeight / currentShape.height;
                    currentShape.tailX = (currentShape.tailX - currentShape.x) * scaleWidth + currentShape.x;
                    currentShape.tailY = (currentShape.tailY - currentShape.y) * scaleHeight + currentShape.y;
                }

                // Update shape properties
                currentShape.width = newWidth;
                currentShape.height = newHeight;

                // Update start position for next move
                startX = x;
                startY = y;
                drawCanvas();
                return;
            }

            // Handle tail movement for SpeechBubble



            if (isTailMoving && selectedShape instanceof SpeechBubble) {
                // Get shape center
                const centerX = selectedShape.x + selectedShape.width / 2;
                const centerY = selectedShape.y + selectedShape.height / 2;
                
                // Transform mouse coordinates to shape's coordinate system
                const dx = x - centerX;
                const dy = y - centerY;
                const angleRad = -selectedShape.rotation * Math.PI / 180;
                const transformedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                const transformedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                
                // Convert back to world coordinates
                selectedShape.tailX = transformedX + centerX;
                selectedShape.tailY = transformedY + centerY;
                
                drawCanvas();
                return;
            }



            // Handle rotation
            if (isRotating && selectedShape) {
                const currentShapeCenter = selectedShape.getCenter();
                const currentAngle = getAngle(currentShapeCenter.x, currentShapeCenter.y, x, y);
                const initialAngle = getAngle(currentShapeCenter.x, currentShapeCenter.y, startX, startY);
                const angleDiffRadians = currentAngle - initialAngle;

                // Update shape's rotation (in degrees)
                let newRotationDegrees = selectedShape.rotation + (angleDiffRadians * 180 / Math.PI);
                newRotationDegrees = (newRotationDegrees % 360 + 360) % 360; // Keep between 0 and 360

                if (selectedShape instanceof Arrow) {
                    selectedShape.applyRotationToPoints(newRotationDegrees); // Applies rotation directly to points
                } else {
                    selectedShape.rotation = newRotationDegrees;
                }

                startX = x; // Update start for next move
                startY = y;
                drawCanvas();
                return;
            }
        }


        /**
         * Handles mouse up (or touch end) events on the canvas.
         * @param {MouseEvent|TouchEvent} event - The event object.
         */
        function handleWheel(e) {
            e.preventDefault(); // Prevent page from scrolling
            const { x, y } = getRawMousePos(e);
            if (e.deltaY < 0) {
                // Scroll up -> zoom in
                zoomIn(x, y);
            } else {
                // Scroll down -> zoom out
                zoomOut(x, y);
            }
        }

        function handleMouseUp(event) {
            console.log('5. Mouse up on canvas.');
            if (drawingMode && isResizing && selectedShape) {
                // Finalize the new shape if it's too small, remove it
                if (selectedShape.width < 10 || selectedShape.height < 10) {
                    shapes.pop(); // Remove the barely drawn shape
                    selectedShape = null;
                    console.log('   New shape too small, removed.');
                } else {
                    console.log('   New shape finalized.');
                }
            }
            drawingMode = null;
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
            isRotating = false;
            rotationHandle = null;
            isTailMoving = false;
            drawCanvas(); // Final redraw
            console.log('   Drawing mode reset to:', drawingMode);
        }

        /**
         * Updates the cursor style based on mouse position and interaction state.
         * @param {number} mouseX - Mouse X coordinate relative to canvas.
         * @param {number} mouseY - Mouse Y coordinate relative to canvas.
         */
         function updateCursor(mouseX, mouseY) {
            // Check for handles
            if (selectedShape) {
                // Check for tail handle
                if (selectedShape instanceof SpeechBubble && selectedShape.onTailHandle(mouseX, mouseY)) {
                    canvas.style.cursor = 'pointer'; // Hand/finger cursor
                    return;
                }
                
                // Check for resize handle
                if (selectedShape.onResizeHandle(mouseX, mouseY) === 'resize') {
                    canvas.style.cursor = 'se-resize'; // Double arrow cursor
                    return;
                }
                
                // Check for rotation handle
                if (isCtrlPressed && selectedShape instanceof SpeechBubble) {
                    const rotationHandle = selectedShape.onRotationHandle(mouseX, mouseY);
                    if (rotationHandle) {
                        canvas.style.cursor = 'grab'; // Grab cursor
                        return;
                    }
                }
            }
    
            if (isDragging || isResizing || isRotating || isTailMoving || drawingMode) {
                canvas.style.cursor = 'grabbing'; // Or specific resize/rotation cursors
                return;
            }

            let hovered = false;
            let newCursor = 'grab'; // Default for interaction

            // Check if hovering over any shape for dragging
            for (let i = shapes.length - 1; i >= 0; i--) {
                const shape = shapes[i];
                if (shape.contains(mouseX, mouseY)) {
                    newCursor = 'grab';
                    hovered = true;
                    // Check for handles only if it's the selected shape
                    if (shape === selectedShape) {
                        // The handle checking is already handled above
                    }
                }
            }
            
            if (hovered) {
                canvas.style.cursor = newCursor;
            } else {
                canvas.style.cursor = 'default';
            }
        }

        // --- Double Click for Editing Modals ---

        canvas.addEventListener('dblclick', handleDoubleClick);
        canvas.addEventListener('wheel', handleWheel, { passive: false });

        function handleDoubleClick(event) {
            const { x, y } = getMousePos(event);

            // Iterate shapes in reverse order to check top-most first
            for (let i = shapes.length - 1; i >= 0; i--) {
                const shape = shapes[i];
                if (shape.contains(x, y)) {
                    selectedShape = shape; // Select the shape for editing
                    if (shape instanceof SpeechBubble) {
                        openBubbleEditor(shape);
                    } else if (shape instanceof Arrow) {
                        openArrowEditor(shape);
                    }
                    drawCanvas();
                    return;
                }
            }
        }



        // --- Keyboard Events ---
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Control') {
                isCtrlPressed = true;
                // Redraw canvas immediately to show handles
                drawCanvas();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Control') {
                isCtrlPressed = false;
                // Redraw canvas immediately to hide handles
                drawCanvas();
            }
        });

        // Ensure Ctrl key state is updated when focus changes
        document.addEventListener('focusin', () => {
            isCtrlPressed = false;
            drawCanvas();
        });

        document.addEventListener('focusout', () => {
            isCtrlPressed = false;
            drawCanvas();
        });

        // Add event listener for window focus change
        window.addEventListener('focus', () => {
            isCtrlPressed = false;
            drawCanvas();
        });

        window.addEventListener('blur', () => {
            isCtrlPressed = false;
            drawCanvas();
        });


        // --- File Menu and Save/Load Functions ---
        const fileMenuBtn = document.getElementById('fileMenuBtn');
        const fileMenuDropdown = document.getElementById('fileMenuDropdown');
        const exportToFileBtn = document.getElementById('exportToFileBtn');
        const importFromFileBtn = document.getElementById('importFromFileBtn');
        const fileInput = document.getElementById('fileInput');
        const zoomLevelLabel = document.getElementById('zoomLevelLabel');

        // Toggle File Menu
        fileMenuBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            fileMenuDropdown.classList.toggle('hidden');
        });

        // Close dropdown when clicking outside
        window.addEventListener('click', (event) => {
            if (!fileMenuBtn.contains(event.target)) {
                fileMenuDropdown.classList.add('hidden');
            }
        });

        // Export canvas state to a JSON file
        function exportToFile() {
            try {
                // Prompt for a filename
                let fileName = prompt("Please enter a name for your project file:", "bubbleup-project");
                if (fileName === null || fileName.trim() === "") {
                    console.log("Export cancelled by user.");
                    return; // Abort if user cancels or enters an empty name
                }

                // Ensure the filename ends with .json
                if (!fileName.toLowerCase().endsWith('.json')) {
                    fileName += '.json';
                }

                const canvasState = {
                    image: uploadedImage ? uploadedImage.src : null,
                    shapes: shapes.map(shape => {
                        const shapeData = { type: shape.constructor.name, properties: {} };
                        Object.assign(shapeData.properties, shape);
                        return shapeData;
                    }),
                    zoom: currentZoom,
                    panX: panX,
                    panY: panY
                };

                const jsonString = JSON.stringify(canvasState, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = fileName; // Use the user-provided filename
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showPointer('exportToFileBtn', 'Exported to file!');
            } catch (error) {
                console.error('Error exporting canvas state:', error);
                alert('Error exporting canvas state: ' + error.message);
            }
        }

        // Main function to apply a state object to the canvas
        function applyState(state) {
            shapes.length = 0;
            uploadedImage = null;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const loadImageAndRestore = () => {
                if (state.shapes && Array.isArray(state.shapes)) {
                    shapes.push(...state.shapes.map(shapeData => {
                        let shape;
                        if (shapeData.type === 'SpeechBubble') {
                            shape = new SpeechBubble(0,0,0,0); // Temp values
                        } else if (shapeData.type === 'Arrow') {
                            shape = new Arrow(0,0,0,0); // Temp values
                        }
                        Object.assign(shape, shapeData.properties);
                        return shape;
                    }));
                }

                currentZoom = state.zoom || 1;
                panX = state.panX || 0;
                panY = state.panY || 0;

                updateZoomLabel();
                drawCanvas();
                console.log('Canvas state restored successfully.');
            };

            if (state.image) {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    loadImageAndRestore();
                };
                img.onerror = () => {
                    console.error("Failed to load image from state.");
                    alert("Error: The saved image could not be loaded.");
                    loadImageAndRestore(); // Still load shapes
                };
                img.src = state.image;
            } else {
                loadImageAndRestore();
            }
        }

        // Add event listeners for file operations
        exportToFileBtn.addEventListener('click', (e) => {
            e.preventDefault();
            exportToFile();
            fileMenuDropdown.classList.add('hidden');
        });

        importFromFileBtn.addEventListener('click', (e) => {
            e.preventDefault();
            fileInput.click();
            fileMenuDropdown.classList.add('hidden');
        });

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const state = JSON.parse(e.target.result);
                    applyState(state);
                    showPointer('importFromFileBtn', 'Imported from file!');
                } catch (error) {
                    console.error('Error importing file:', error);
                    alert('Error importing file: ' + error.message);
                } finally {
                    fileInput.value = ''; // Reset for next import
                }
            };
            reader.onerror = () => alert('Error reading the file.');
            reader.readAsText(file);
        });

        // --- Copy/Paste State ---
        let copiedBubble = null;
        let copiedArrow = null;

        // --- Button Event Listeners ---

        // Copy bubble button
        copyBubbleBtn.addEventListener('click', () => {
            if (!selectedShape || !(selectedShape instanceof SpeechBubble)) {
                alert('Please select a speech bubble to copy!');
                return;
            }
            
            // Store all bubble properties for paste
            copiedBubble = {
                x: selectedShape.x,
                y: selectedShape.y,
                width: selectedShape.width,
                height: selectedShape.height,
                text: selectedShape.text,
                fontSize: selectedShape.fontSize,
                fontFamily: selectedShape.fontFamily,
                textColor: selectedShape.textColor,
                fillColor: selectedShape.fillColor,
                fillTransparency: selectedShape.fillTransparency,
                borderColor: selectedShape.borderColor,
                borderTransparency: selectedShape.borderTransparency,
                borderWidth: selectedShape.borderWidth,
                tailBaseSide: selectedShape.tailBaseSide,
                tailBaseAlignment: selectedShape.tailBaseAlignment,
                paddingX: selectedShape.paddingX,
                paddingY: selectedShape.paddingY,
                cornerRadius: selectedShape.cornerRadius,
                flipText: selectedShape.flipText,
                tailBaseWidth: selectedShape.tailBaseWidth,
                tailX: selectedShape.tailX,
                tailY: selectedShape.tailY,
                tailTipX: selectedShape.tailTipX,
                tailTipY: selectedShape.tailTipY
            };
            
            // Visual feedback
            copyBubbleBtn.style.backgroundColor = '#34d399'; // Change to success green
            setTimeout(() => {
                copyBubbleBtn.style.backgroundColor = ''; // Reset color
            }, 1000);
            
            console.log('Copied bubble properties:', copiedBubble);
        });

        // Copy arrow button
        const copyArrowBtn = document.getElementById('copyArrowBtn');
        copyArrowBtn.addEventListener('click', () => {
            if (!selectedShape || !(selectedShape instanceof Arrow)) {
                alert('Please select an arrow to copy!');
                return;
            }
            
            // Store all arrow properties for paste
            copiedArrow = {
                x1: selectedShape.x1,
                y1: selectedShape.y1,
                x2: selectedShape.x2,
                y2: selectedShape.y2,
                text: selectedShape.text,
                fontSize: selectedShape.fontSize,
                fontFamily: selectedShape.fontFamily,
                textColor: selectedShape.textColor,
                fillColor: selectedShape.fillColor,
                fillTransparency: selectedShape.fillTransparency,
                borderColor: selectedShape.borderColor,
                borderTransparency: selectedShape.borderTransparency,
                borderWidth: selectedShape.borderWidth,
                lineWidth: selectedShape.lineWidth,
                headSize: selectedShape.headSize,
                paddingX: selectedShape.paddingX,
                paddingY: selectedShape.paddingY,
                flipText: selectedShape.flipText,
                rotation: selectedShape.rotation
            };
            
            // Visual feedback
            copyArrowBtn.style.backgroundColor = '#34d399'; // Change to success green
            setTimeout(() => {
                copyArrowBtn.style.backgroundColor = ''; // Reset color
            }, 1000);
            
            console.log('Copied arrow properties:', copiedArrow);
        });

        // Paste bubble button
        pasteBubbleBtn.addEventListener('click', () => {
            if (!copiedBubble) {
                alert('No bubble properties copied yet! Please copy a bubble first.');
                return;
            }
            
            // Get current mouse position or use center
            const mousePos = getMousePos({ clientX: canvas.width / 2, clientY: canvas.height / 2 });
            
            // Create new bubble with original dimensions
            const newBubble = new SpeechBubble(mousePos.x, mousePos.y, 
                copiedBubble.width || 100, // Use original width with fallback
                copiedBubble.height || 50, // Use original height with fallback
                copiedBubble.text, copiedBubble.fontSize, copiedBubble.fontFamily, copiedBubble.textColor
            );
            
            // Copy all properties including dimensions and tail properties
            const propertiesToCopy = {
                text: copiedBubble.text || 'Hello!',
                fontSize: copiedBubble.fontSize || 24,
                fontFamily: copiedBubble.fontFamily || 'Inter',
                textColor: copiedBubble.textColor || '#000000',
                fillColor: copiedBubble.fillColor || '#ffffff',
                fillTransparency: copiedBubble.fillTransparency !== undefined ? parseFloat(copiedBubble.fillTransparency) : 1,
                borderColor: copiedBubble.borderColor || '#000000',
                borderTransparency: copiedBubble.borderTransparency !== undefined ? parseFloat(copiedBubble.borderTransparency) : 1,
                borderWidth: copiedBubble.borderWidth !== undefined ? parseFloat(copiedBubble.borderWidth) : 2,
                width: copiedBubble.width || 100, // Use copied width with fallback
                height: copiedBubble.height || 50, // Use copied height with fallback
                tailBaseSide: copiedBubble.tailBaseSide || 'bottom',
                tailBaseAlignment: copiedBubble.tailBaseAlignment || 'center',
                paddingX: copiedBubble.paddingX !== undefined ? parseFloat(copiedBubble.paddingX) : 15,
                paddingY: copiedBubble.paddingY !== undefined ? parseFloat(copiedBubble.paddingY) : 10,
                cornerRadius: copiedBubble.cornerRadius !== undefined ? parseFloat(copiedBubble.cornerRadius) : 15,
                flipText: copiedBubble.flipText || false,
                // Copy tail properties
                tailBaseWidth: copiedBubble.tailBaseWidth,
                tailX: copiedBubble.tailX,
                tailY: copiedBubble.tailY,
                tailTipX: copiedBubble.tailTipX,
                tailTipY: copiedBubble.tailTipY
            };
            
            // Update the bubble with copied properties
            newBubble.updateFromEditor(propertiesToCopy);
            
            // Update tail position based on new properties
            newBubble.updateTailTipPosition();
            
            // Add to shapes array
            shapes.push(newBubble);
            
            // Select and open editor
            selectedShape = newBubble;
            openBubbleEditor(newBubble);
            
            // Redraw canvas
            drawCanvas();
            
            // Visual feedback
            pasteBubbleBtn.style.backgroundColor = '#3b82f6'; // Change to success blue
            setTimeout(() => {
                pasteBubbleBtn.style.backgroundColor = ''; // Reset color
            }, 1000);
            
            console.log('Pasted bubble with properties:', newBubble);
        });

        // Paste arrow button
        const pasteArrowBtn = document.getElementById('pasteArrowBtn');
        pasteArrowBtn.addEventListener('click', () => {
            if (!copiedArrow) {
                alert('No arrow properties copied yet! Please copy an arrow first.');
                return;
            }
            
            // Get current mouse position or use center
            const mousePos = getMousePos({ clientX: canvas.width / 2, clientY: canvas.height / 2 });
            
            // Calculate new arrow endpoints based on original direction
            const dx = copiedArrow.x2 - copiedArrow.x1;
            const dy = copiedArrow.y2 - copiedArrow.y1;
            const newArrow = new Arrow(
                mousePos.x,
                mousePos.y,
                mousePos.x + dx,
                mousePos.y + dy,
                copiedArrow.text || '',
                copiedArrow.fontSize || 16,
                copiedArrow.fontFamily || 'Inter',
                copiedArrow.textColor || '#000000'
            );
            
            // Copy all arrow properties, ensuring colors are properly copied
            const propertiesToCopy = {
                text: copiedArrow.text || '',
                fontSize: copiedArrow.fontSize || 16,
                fontFamily: copiedArrow.fontFamily || 'Inter',
                textColor: copiedArrow.textColor || '#000000',
                fillColor: copiedArrow.fillColor || '#ffffff',
                fillTransparency: copiedArrow.fillTransparency !== undefined ? parseFloat(copiedArrow.fillTransparency) : 1,
                borderColor: copiedArrow.borderColor || '#000000',
                borderTransparency: copiedArrow.borderTransparency !== undefined ? parseFloat(copiedArrow.borderTransparency) : 1,
                borderWidth: copiedArrow.borderWidth !== undefined ? parseFloat(copiedArrow.borderWidth) : 2,
                lineWidth: copiedArrow.lineWidth !== undefined ? parseFloat(copiedArrow.lineWidth) : 2,
                headSize: copiedArrow.headSize !== undefined ? parseFloat(copiedArrow.headSize) : 10,
                paddingX: copiedArrow.paddingX !== undefined ? parseFloat(copiedArrow.paddingX) : 10,
                paddingY: copiedArrow.paddingY !== undefined ? parseFloat(copiedArrow.paddingY) : 5,
                flipText: copiedArrow.flipText || false,
                rotation: copiedArrow.rotation !== undefined ? parseFloat(copiedArrow.rotation) : 0
            };
            
            // Set colors explicitly before updateFromEditor
            newArrow.fillColor = propertiesToCopy.fillColor;
            newArrow.fillTransparency = propertiesToCopy.fillTransparency;
            newArrow.textColor = propertiesToCopy.textColor; // Ensure text color is copied
            
            // Set the text background color explicitly
            newArrow.textBackgroundColor = propertiesToCopy.fillColor;
            newArrow.textBackgroundTransparency = propertiesToCopy.fillTransparency;
            
            // Update the arrow with copied properties
            newArrow.updateFromEditor(propertiesToCopy);
            
            // Update the arrow with copied properties
            newArrow.updateFromEditor(propertiesToCopy);
            
            // Add to shapes array
            shapes.push(newArrow);
            
            // Select and open editor
            selectedShape = newArrow;
            openArrowEditor(newArrow);
            
            // Redraw canvas
            drawCanvas();
            
            // Visual feedback
            pasteArrowBtn.style.backgroundColor = '#3b82f6'; // Change to success blue
            setTimeout(() => {
                pasteArrowBtn.style.backgroundColor = ''; // Reset color
            }, 1000);
            
            console.log('Pasted arrow with properties:', newArrow);
        });

        uploadImageBtn.addEventListener('click', () => {
            imageInput.click(); // Trigger hidden file input click
        });

        imageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                // Clear existing shapes and reset state
                shapes = [];
                selectedShape = null;
                drawingMode = null;
                isDragging = false;
                isResizing = false;
                isRotating = false;
                resizeHandle = null;
                rotationHandle = null;
                isTailMoving = false;
                
                // Reset pan and zoom
                currentZoom = 1;
                panX = 0;
                panY = 0;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImage = img;
                        
                        // Calculate optimal zoom level to fit image in canvas
                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;
                        const imageAspectRatio = img.width / img.height;
                        const canvasAspectRatio = canvasWidth / canvasHeight;
                        
                        let zoomX = canvasWidth / img.width;
                        let zoomY = canvasHeight / img.height;
                        let finalZoom = Math.min(zoomX, zoomY) * 0.95; // Leave a small margin
                        
                        // Calculate pan position to center the image
                        const imageWidth = img.width * finalZoom;
                        const imageHeight = img.height * finalZoom;
                        panX = (canvasWidth - imageWidth) / 2;
                        panY = (canvasHeight - imageHeight) / 2;
                        
                        // Update zoom and pan
                        currentZoom = finalZoom;
                        
                        // Redraw canvas with new image
                        drawCanvas();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Create Bubble button handler
        createBubbleBtn.addEventListener('click', () => {
            console.log('1. Create Bubble button clicked.');
            drawingMode = 'bubble';
            selectedShape = null; // Deselect any existing shape
            isDragging = false;
            isResizing = false;
            isRotating = false;
            resizeHandle = null;
            rotationHandle = null;
            isTailMoving = false;
            canvas.style.cursor = 'crosshair';
            console.log('   drawingMode set to:', drawingMode);
            drawCanvas();
        });

        // Create Arrow button handler
        createArrowBtn.addEventListener('click', () => {
            drawingMode = 'arrow';
            selectedShape = null; // Deselect any existing shape
            canvas.style.cursor = 'crosshair';
            drawCanvas();
        });

        saveImageBtn.addEventListener('click', function() {
            if (!uploadedImage) {
                alert('No image uploaded yet!');
                return;
            }

            // Create a temporary canvas with the same size as the original image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = uploadedImage.width;
            tempCanvas.height = uploadedImage.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw only the image area
            tempCtx.drawImage(uploadedImage, 0, 0);

            // Draw shapes on top of the image
            shapes.forEach(shape => {
                shape.draw(tempCtx, false, false); // Don't show selection handles or Ctrl features
            });

            // Create download link
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = tempCanvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        saveClipBtn.addEventListener('click', function() {
            // Create download link for the entire canvas
            const link = document.createElement('a');
            link.download = 'canvas-view.png';
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        clearCanvasBtn.addEventListener('click', () => {
            showConfirmModal('Are you sure you want to clear the canvas? This action cannot be undone.', (confirmed) => {
                if (confirmed) {
                    uploadedImage = null;
                    shapes = [];
                    selectedShape = null;
                    drawingMode = null;
                    currentZoom = 1;
                    panX = 0;
                    panY = 0;
                    drawCanvas();
                }
            });
        });

        howToBtn.addEventListener('click', () => {
            howToModal.classList.remove('hidden');
        });

        closeHowToBtn.addEventListener('click', () => {
            howToModal.classList.add('hidden');
        });


        // --- Zoom Controls ---
        function updateZoomLabel() {
            zoomLevelLabel.textContent = `Zoom: ${Math.round(currentZoom * 100)}%`;
        }

        function zoomIn(mouseX, mouseY) {
            const oldZoom = currentZoom;
            let newZoom = currentZoom * 1.1;
            if (newZoom > 4) newZoom = 4; // Max zoom

            // Adjust pan to keep the point under the mouse stationary
            panX = (panX - mouseX) * (newZoom / oldZoom) + mouseX;
            panY = (panY - mouseY) * (newZoom / oldZoom) + mouseY;
            
            currentZoom = newZoom;
            updateZoomLabel();
            drawCanvas();
        }

        function zoomOut(mouseX, mouseY) {
            const oldZoom = currentZoom;
            let newZoom = currentZoom / 1.1;
            if (newZoom < 0.1) newZoom = 0.1; // Min zoom

            // Adjust pan to keep the point under the mouse stationary
            panX = (panX - mouseX) * (newZoom / oldZoom) + mouseX;
            panY = (panY - mouseY) * (newZoom / oldZoom) + mouseY;

            currentZoom = newZoom;
            updateZoomLabel();
            drawCanvas();
        }

        zoomInBtn.addEventListener('click', () => {
            zoomIn(canvas.width / 2, canvas.height / 2);
        });

        zoomOutBtn.addEventListener('click', () => {
            zoomOut(canvas.width / 2, canvas.height / 2);
        });

        resetZoomBtn.addEventListener('click', () => {
            currentZoom = 1;
            panX = 0;
            panY = 0;
            updateZoomLabel();
            drawCanvas();
        });

        // --- Speech Bubble Editor Modal Logic ---

        function openBubbleEditor(bubble) {
            // Get all the form elements
            const bubbleText = document.getElementById('bubbleText');
            const bubbleFontSize = document.getElementById('bubbleFontSize');
            const bubbleFont = document.getElementById('bubbleFont');
            const bubbleFill = document.getElementById('bubbleFill');
            const bubbleFillTransparency = document.getElementById('bubbleFillTransparency');
            const bubbleFillTransparencyValue = document.getElementById('bubbleFillTransparencyValue');
            const bubbleBorderColor = document.getElementById('bubbleBorderColor');
            const bubbleBorderTransparency = document.getElementById('bubbleBorderTransparency');
            const bubbleBorderTransparencyValue = document.getElementById('bubbleBorderTransparencyValue');
            const bubbleBorderWidth = document.getElementById('bubbleBorderWidth');
            const bubbleTextColor = document.getElementById('bubbleTextColor');
            const bubbleTailSide = document.getElementById('bubbleTailSide');
            const bubbleTailAlignment = document.getElementById('bubbleTailAlignment');
            const bubblePaddingX = document.getElementById('bubblePaddingX');
            const bubblePaddingY = document.getElementById('bubblePaddingY');
            const bubbleRotation = document.getElementById('bubbleRotation');
            const bubbleTailLength = document.getElementById('bubbleTailLength');
            const bubbleTailWidth = document.getElementById('bubbleTailWidth');

            // Set all values
            bubbleText.value = bubble.text;
            bubbleFontSize.value = bubble.fontSize;
            bubbleFont.value = bubble.fontFamily;
            bubbleFill.value = bubble.fillColor;
            bubbleFillTransparency.value = bubble.fillTransparency;
            bubbleFillTransparencyValue.textContent = bubble.fillTransparency.toFixed(2);
            bubbleBorderColor.value = bubble.borderColor;
            bubbleBorderTransparency.value = bubble.borderTransparency;
            bubbleBorderTransparencyValue.textContent = bubble.borderTransparency.toFixed(2);
            bubbleBorderWidth.value = bubble.borderWidth;
            bubbleTextColor.value = bubble.textColor;
            bubbleTailSide.value = bubble.tailSide;
            bubbleTailAlignment.value = bubble.tailAlignment;
            bubblePaddingX.value = bubble.paddingX;
            bubblePaddingY.value = bubble.paddingY;
            bubbleRotation.value = bubble.rotation;
            bubbleTailLength.value = bubble.tailLength;
            bubbleTailWidth.value = bubble.tailWidth;

            // Show the modal
            bubbleEditorModal.classList.remove('hidden');
        }

        bubbleFillTransparency.addEventListener('input', (e) => {
            bubbleFillTransparencyValue.textContent = parseFloat(e.target.value).toFixed(2);
        });

        bubbleBorderTransparency.addEventListener('input', (e) => {
            bubbleBorderTransparencyValue.textContent = parseFloat(e.target.value).toFixed(2);
        });


        applyBubbleBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (selectedShape && selectedShape instanceof SpeechBubble) {
                selectedShape.updateFromEditor({
                    text: bubbleText.value,
                    fontSize: bubbleFontSize.value,
                    fontFamily: bubbleFontFamily.value,
                    rotation: bubbleRotation.value,
                    fillColor: bubbleFillColor.value,
                    fillTransparency: bubbleFillTransparency.value,
                    borderColor: bubbleBorderColor.value,
                    borderTransparency: bubbleBorderTransparency.value,
                    borderWidth: bubbleBorderWidth.value,
                    textColor: bubbleTextColor.value,
                    tailBaseSide: bubbleTailSide.value, // Get new dropdown value
                    tailBaseAlignment: bubbleTailAlignment.value, // Get new dropdown value
                    tailBaseWidth: bubbleTailBaseWidth.value,
                    paddingX: bubblePaddingX.value,
                    paddingY: bubblePaddingY.value,
                    cornerRadius: bubbleCornerRadius.value,
                    flipText: bubbleFlipText.checked
                });
                drawCanvas();
            }
            bubbleEditorModal.classList.add('hidden');
        });

        cancelBubbleBtn.addEventListener('click', () => {
            bubbleEditorModal.classList.add('hidden');
            selectedShape = null; // Deselect on cancel
            drawCanvas();
        });

        deleteBubbleBtn.addEventListener('click', () => {
            showConfirmModal('Are you sure you want to delete this speech bubble?', (confirmed) => {
                if (confirmed) {
                    if (selectedShape) {
                        shapes = shapes.filter(s => s !== selectedShape);
                        selectedShape = null;
                        drawCanvas();
                    }
                    bubbleEditorModal.classList.add('hidden');
                }
            });
        });

        // --- Arrow Editor Modal Logic ---

        function openArrowEditor(arrow) {
            arrowText.value = arrow.text;
            arrowFontSize.value = arrow.fontSize;
            arrowFontFamily.value = arrow.fontFamily;
            arrowRotation.value = arrow.rotation;
            arrowFillColor.value = arrow.fillColor; // Line color
            arrowFillTransparency.value = arrow.fillTransparency;
            arrowFillTransparencyValue.textContent = parseFloat(arrow.fillTransparency).toFixed(2);
            arrowTextColor.value = arrow.textColor;
            arrowTextBackgroundColor.value = arrow.textBackgroundColor;
            arrowLineWidth.value = arrow.lineWidth;
            arrowHeadSize.value = arrow.headSize;
            arrowPaddingX.value = arrow.paddingX;
            arrowPaddingY.value = arrow.paddingY;
            arrowFlipText.checked = arrow.flipText;
            arrowEditorModal.classList.remove('hidden');
        }

        arrowFillTransparency.addEventListener('input', (e) => {
            arrowFillTransparencyValue.textContent = parseFloat(e.target.value).toFixed(2);
        });

        applyArrowBtn.addEventListener('click', (e) => {
            e.preventDefault();
            if (selectedShape && selectedShape instanceof Arrow) {
                selectedShape.updateFromEditor({
                    text: arrowText.value,
                    fontSize: arrowFontSize.value,
                    fontFamily: arrowFontFamily.value,
                    rotation: arrowRotation.value,
                    fillColor: arrowFillColor.value,
                    fillTransparency: arrowFillTransparency.value,
                    textColor: arrowTextColor.value,
                    textBackgroundColor: arrowTextBackgroundColor.value,
                    lineWidth: arrowLineWidth.value,
                    headSize: arrowHeadSize.value,
                    paddingX: arrowPaddingX.value,
                    paddingY: arrowPaddingY.value,
                    flipText: arrowFlipText.checked
                });
                drawCanvas();
            }
            arrowEditorModal.classList.add('hidden');
        });

        cancelArrowBtn.addEventListener('click', () => {
            arrowEditorModal.classList.add('hidden');
            selectedShape = null; // Deselect on cancel
            drawCanvas();
        });

        clearCanvasBtn.addEventListener('click', () => {
            showConfirmModal('Are you sure you want to clear the entire canvas?', (confirmed) => {
                if (confirmed) {
                    // Reset all canvas state
                    uploadedImage = null;
                    shapes = [];
                    selectedShape = null;
                    drawingMode = null;
                    currentZoom = 1;
                    panX = 0;
                    panY = 0;
                    isDragging = false;
                    isResizing = false;
                    resizeHandle = null;
                    isRotating = false;
                    rotationHandle = null;
                    isTailMoving = false;
                    
                    // Reset file input to allow selecting the same file again
                    const fileInput = document.getElementById('imageInput');
                    if (fileInput) {
                        fileInput.value = '';
                    }
                    
                    drawCanvas();
                }
            });
        });

        deleteArrowBtn.addEventListener('click', () => {
            showConfirmModal('Are you sure you want to delete this arrow?', (confirmed) => {
                if (confirmed) {
                    if (selectedShape) {
                        shapes = shapes.filter(s => s !== selectedShape);
                        selectedShape = null;
                        drawCanvas();
                    }
                    arrowEditorModal.classList.add('hidden');
                }
            });
        });

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey) {
                isCtrlPressed = true;
                updateCursor(e.clientX, e.clientY);
            }

            // Handle delete key
            if (e.key === 'Delete' && selectedShape) {
                const confirmDelete = confirm('Are you sure you want to delete this shape?');
                if (confirmDelete) {
                    shapes = shapes.filter(shape => shape !== selectedShape);
                    selectedShape = null;
                    drawCanvas();
                }
            }

            // Handle Ctrl+C (Copy)
            if (e.ctrlKey && e.key === 'c') {
                e.preventDefault(); // Prevent default browser copy behavior
                
                if (!selectedShape) {
                    alert('Please select a shape to copy!');
                    return;
                }
                
                // Reset any existing copied shape
                if (selectedShape instanceof SpeechBubble) {
                    copiedBubble = {
                        text: selectedShape.text,
                        fontSize: selectedShape.fontSize,
                        fontFamily: selectedShape.fontFamily,
                        textColor: selectedShape.textColor,
                        fillColor: selectedShape.fillColor,
                        fillTransparency: selectedShape.fillTransparency,
                        borderColor: selectedShape.borderColor,
                        borderTransparency: selectedShape.borderTransparency,
                        borderWidth: selectedShape.borderWidth,
                        width: selectedShape.width,
                        height: selectedShape.height,
                        tailBaseSide: selectedShape.tailBaseSide,
                        tailBaseAlignment: selectedShape.tailBaseAlignment,
                        paddingX: selectedShape.paddingX,
                        paddingY: selectedShape.paddingY,
                        cornerRadius: selectedShape.cornerRadius,
                        flipText: selectedShape.flipText,
                        tailBaseWidth: selectedShape.tailBaseWidth,
                        tailX: selectedShape.tailX,
                        tailY: selectedShape.tailY,
                        tailTipX: selectedShape.tailTipX,
                        tailTipY: selectedShape.tailTipY
                    };
                    copiedArrow = null; // Clear any existing arrow copy
                    
                    // Visual feedback
                    copyBubbleBtn.style.backgroundColor = '#34d399'; // Change to success green
                    setTimeout(() => {
                        copyBubbleBtn.style.backgroundColor = ''; // Reset color
                    }, 1000);
                    
                    console.log('Copied bubble properties:', copiedBubble);
                } else if (selectedShape instanceof Arrow) {
                    copiedArrow = {
                        x1: selectedShape.x1,
                        y1: selectedShape.y1,
                        x2: selectedShape.x2,
                        y2: selectedShape.y2,
                        text: selectedShape.text,
                        fontSize: selectedShape.fontSize,
                        fontFamily: selectedShape.fontFamily,
                        textColor: selectedShape.textColor,
                        fillColor: selectedShape.fillColor,
                        fillTransparency: selectedShape.fillTransparency,
                        borderColor: selectedShape.borderColor,
                        borderTransparency: selectedShape.borderTransparency,
                        borderWidth: selectedShape.borderWidth,
                        lineWidth: selectedShape.lineWidth,
                        headSize: selectedShape.headSize,
                        paddingX: selectedShape.paddingX,
                        paddingY: selectedShape.paddingY,
                        flipText: selectedShape.flipText,
                        rotation: selectedShape.rotation,
                        textBackgroundColor: selectedShape.textBackgroundColor,
                        textBackgroundTransparency: selectedShape.textBackgroundTransparency
                    };
                    copiedBubble = null; // Clear any existing bubble copy
                    
                    // Visual feedback
                    copyArrowBtn.style.backgroundColor = '#34d399'; // Change to success green
                    setTimeout(() => {
                        copyArrowBtn.style.backgroundColor = ''; // Reset color
                    }, 1000);
                    
                    console.log('Copied arrow properties:', copiedArrow);
                }
            }

            // Handle Ctrl+V (Paste)
            if (e.ctrlKey && e.key === 'v') {
                e.preventDefault(); // Prevent default browser paste behavior
                
                if (copiedBubble) {
                    // Paste bubble
                    const mousePos = getMousePos({ clientX: canvas.width / 2, clientY: canvas.height / 2 });
                    const newBubble = new SpeechBubble(mousePos.x, mousePos.y, 
                        copiedBubble.width || 100, // Use original width with fallback
                        copiedBubble.height || 50, // Use original height with fallback
                        copiedBubble.text, copiedBubble.fontSize, copiedBubble.fontFamily, copiedBubble.textColor
                    );
                    
                    // Copy all properties including dimensions and tail properties
                    const propertiesToCopy = {
                        text: copiedBubble.text || 'Hello!',
                        fontSize: copiedBubble.fontSize || 24,
                        fontFamily: copiedBubble.fontFamily || 'Inter',
                        textColor: copiedBubble.textColor || '#000000',
                        fillColor: copiedBubble.fillColor || '#ffffff',
                        fillTransparency: copiedBubble.fillTransparency !== undefined ? parseFloat(copiedBubble.fillTransparency) : 1,
                        borderColor: copiedBubble.borderColor || '#000000',
                        borderTransparency: copiedBubble.borderTransparency !== undefined ? parseFloat(copiedBubble.borderTransparency) : 1,
                        borderWidth: copiedBubble.borderWidth !== undefined ? parseFloat(copiedBubble.borderWidth) : 2,
                        width: copiedBubble.width || 100, // Use copied width with fallback
                        height: copiedBubble.height || 50, // Use copied height with fallback
                        tailBaseSide: copiedBubble.tailBaseSide || 'bottom',
                        tailBaseAlignment: copiedBubble.tailBaseAlignment || 'center',
                        paddingX: copiedBubble.paddingX !== undefined ? parseFloat(copiedBubble.paddingX) : 15,
                        paddingY: copiedBubble.paddingY !== undefined ? parseFloat(copiedBubble.paddingY) : 10,
                        cornerRadius: copiedBubble.cornerRadius !== undefined ? parseFloat(copiedBubble.cornerRadius) : 15,
                        flipText: copiedBubble.flipText || false,
                        tailBaseWidth: copiedBubble.tailBaseWidth,
                        tailX: copiedBubble.tailX,
                        tailY: copiedBubble.tailY,
                        tailTipX: copiedBubble.tailTipX,
                        tailTipY: copiedBubble.tailTipY
                    };
                    
                    // Update the bubble with copied properties
                    newBubble.updateFromEditor(propertiesToCopy);
                    
                    // Add to shapes array
                    shapes.push(newBubble);
                    
                    // Select the new bubble
                    selectedShape = newBubble;
                    
                    // Redraw canvas
                    drawCanvas();
                    
                    // Visual feedback
                    pasteBubbleBtn.style.backgroundColor = '#3b82f6'; // Change to success blue
                    setTimeout(() => {
                        pasteBubbleBtn.style.backgroundColor = ''; // Reset color
                    }, 1000);
                    
                    console.log('Pasted bubble with properties:', newBubble);
                } else if (copiedArrow) {
                    // Paste arrow
                    const mousePos = getMousePos({ clientX: canvas.width / 2, clientY: canvas.height / 2 });
                    
                    // Calculate new arrow endpoints based on original direction
                    const dx = copiedArrow.x2 - copiedArrow.x1;
                    const dy = copiedArrow.y2 - copiedArrow.y1;
                    const newArrow = new Arrow(
                        mousePos.x,
                        mousePos.y,
                        mousePos.x + dx,
                        mousePos.y + dy,
                        copiedArrow.text || '',
                        copiedArrow.fontSize || 16,
                        copiedArrow.fontFamily || 'Inter',
                        copiedArrow.textColor || '#000000'
                    );
                    
                    // Copy all arrow properties
                    const propertiesToCopy = {
                        text: copiedArrow.text || '',
                        fontSize: copiedArrow.fontSize || 16,
                        fontFamily: copiedArrow.fontFamily || 'Inter',
                        textColor: copiedArrow.textColor || '#000000',
                        fillColor: copiedArrow.fillColor || '#ffffff',
                        fillTransparency: copiedArrow.fillTransparency !== undefined ? parseFloat(copiedArrow.fillTransparency) : 1,
                        borderColor: copiedArrow.borderColor || '#000000',
                        borderTransparency: copiedArrow.borderTransparency !== undefined ? parseFloat(copiedArrow.borderTransparency) : 1,
                        borderWidth: copiedArrow.borderWidth !== undefined ? parseFloat(copiedArrow.borderWidth) : 2,
                        lineWidth: copiedArrow.lineWidth !== undefined ? parseFloat(copiedArrow.lineWidth) : 2,
                        headSize: copiedArrow.headSize !== undefined ? parseFloat(copiedArrow.headSize) : 10,
                        paddingX: copiedArrow.paddingX !== undefined ? parseFloat(copiedArrow.paddingX) : 10,
                        paddingY: copiedArrow.paddingY !== undefined ? parseFloat(copiedArrow.paddingY) : 5,
                        flipText: copiedArrow.flipText || false,
                        rotation: copiedArrow.rotation !== undefined ? parseFloat(copiedArrow.rotation) : 0,
                        textBackgroundColor: copiedArrow.textBackgroundColor || '#ffffff',
                        textBackgroundTransparency: copiedArrow.textBackgroundTransparency !== undefined ? parseFloat(copiedArrow.textBackgroundTransparency) : 1
                    };
                    
                    // Set colors explicitly before updateFromEditor
                    newArrow.fillColor = propertiesToCopy.fillColor;
                    newArrow.fillTransparency = propertiesToCopy.fillTransparency;
                    newArrow.textColor = propertiesToCopy.textColor; // Ensure text color is copied
                    
                    // Set the text background color explicitly
                    newArrow.textBackgroundColor = propertiesToCopy.textBackgroundColor;
                    newArrow.textBackgroundTransparency = propertiesToCopy.textBackgroundTransparency;
                    
                    // Update the arrow with copied properties
                    newArrow.updateFromEditor(propertiesToCopy);
                    
                    // Add to shapes array
                    shapes.push(newArrow);
                    
                    // Select the new arrow
                    selectedShape = newArrow;
                    
                    // Redraw canvas
                    drawCanvas();
                    
                    // Visual feedback
                    pasteArrowBtn.style.backgroundColor = '#3b82f6'; // Change to success blue
                    setTimeout(() => {
                        pasteArrowBtn.style.backgroundColor = ''; // Reset color
                    }, 1000);
                    
                    console.log('Pasted arrow with properties:', newArrow);
                } else {
                    alert('No shape properties copied yet! Please copy a shape first.');
                }
            }

        });
        
        arrowEditorModal.classList.add('hidden');


    </script>

    <!-- Prevents Flash of Unstyled Content (FOUC) by waiting for all resources to load -->
    <script>
        window.addEventListener('load', () => {
            document.body.style.opacity = '1';
        });
    </script>

</body>
</html>
